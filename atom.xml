<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fish</title>
  
  <subtitle>Cheer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://herasu.github.io/"/>
  <updated>2019-10-30T06:42:21.643Z</updated>
  <id>https://herasu.github.io/</id>
  
  <author>
    <name>herasu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一种快速、不区分格式的检测恶意Web内容的深度学习方法</title>
    <link href="https://herasu.github.io/2019/10/30/%E4%B8%80%E7%A7%8D%E5%BF%AB%E9%80%9F%E3%80%81%E4%B8%8D%E5%8C%BA%E5%88%86%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%A3%80%E6%B5%8B%E6%81%B6%E6%84%8FWeb%E5%86%85%E5%AE%B9%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <id>https://herasu.github.io/2019/10/30/一种快速、不区分格式的检测恶意Web内容的深度学习方法/</id>
    <published>2019-10-30T06:46:19.743Z</published>
    <updated>2019-10-30T06:42:21.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一种快速、不区分格式的检测恶意Web内容的深度学习方法"><a href="#一种快速、不区分格式的检测恶意Web内容的深度学习方法" class="headerlink" title="一种快速、不区分格式的检测恶意Web内容的深度学习方法"></a>一种快速、不区分格式的检测恶意Web内容的深度学习方法</h1><p><strong>作者</strong>：fish@DAS</p><p><strong>原文作者</strong>：Joshua Saxe(<a href="https://www.sophos.com/en-us/labs/researchers/joshua-saxe.aspx" target="_blank" rel="noopener">主页</a>), Richard Harang, Cody Wild, Hillary Sanders</p><p><strong>原文标题</strong>：A Deep Learning Approach to Fast, Format-Agnostic Detection of Malicious Web Content.</p><p><strong>原文会议</strong>：2018 IEEE Security and Privacy Workshops (SPW)</p><p><strong>原文链接</strong>：<a href="https://arxiv.org/abs/1804.05020" target="_blank" rel="noopener">https://arxiv.org/abs/1804.05020</a></p><h2 id="一、论文主要内容："><a href="#一、论文主要内容：" class="headerlink" title="一、论文主要内容："></a>一、论文主要内容：</h2><p>本文主要内容是使用深度学习检恶意web内容，提出的方法是直接使用简单正则表达式从静态HTML文件中提取的与语言无关的token流来表示HTML，再将该HTML文档的特征表示输入到神经网络中。该方法具有快速、不区分格式等特点，适合部署于终端、防火墙与web代理中。</p><h2 id="二、作者的工作："><a href="#二、作者的工作：" class="headerlink" title="二、作者的工作："></a>二、作者的工作：</h2><h3 id="2-1问题提出"><a href="#2-1问题提出" class="headerlink" title="2.1问题提出"></a>2.1问题提出</h3><p>恶意web内容是网络攻击的一大方式，利用恶意web内容的攻击在当今的网络上非常普遍。<br>作者认为检测和阻止此类恶意内容存在以下挑战：</p><ul><li>首先，检测方法必须在用户终端和防火墙中的硬件上快速运行，以免影响用户的浏览体验。</li><li>其次，方法必须能够抵御恶意Web内容中的语法和语义变化，从而避免诸如Javascript模糊处理和文本随机化之类的对抗性规避技术。</li><li>最后，检测方法必须能够处理局部恶意内容的情况：嵌入正常的Web内容中的小段恶意代码。 因为当今的许多网络攻击都是在良性网页中通过恶意的广告网络或评论来实现的。</li></ul><p>为了解决这些挑战，本文提出了一种用于检测恶意Web内容的深度学习方法。</p><h3 id="2-2模型设计"><a href="#2-2模型设计" class="headerlink" title="2.2模型设计"></a>2.2模型设计</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>首先对于局部恶意片段，作者认为要确定给定的文档是恶意的，需要模型在多个层次规模上检查该文档。这是因为恶意Javascript代码段的大小范围很小，但是HTML文档的长度差异很大，所以恶意内容部分在整个HTML文档比例中是可变的。</p><p>作者还认为不应该显式分析HTML文档（HTML，Javascript，CSS和原始数据的集合），愿意是实现起来复杂，需要大量的计算开销，并且会在检测器自身内部打开攻击页面，这有可能潜在地被攻击者利用。事实上web页面中可执行部分是有JavaScript控制的，因此也不应该在HTML文档中进行Javascript的仿真，静态分析或符号执行。</p><p>到此，思路清晰。作者仅仅对HTML文档计算词袋样式的token，并且不只使用表示整个文档token流，还使用多个不同层次规模大小的表示文档的token流。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>本文方法包括一个特征提取器和一个神经网络模型，特征提取器即从HTML文档中解析出一系列token，神经网络模型通过使用多个层次规模的聚合特征的共享权重来进行分类。其中神经网络模型部分包括两个逻辑组件：</p><ul><li>inspector，它以不同层次规模大小的文档按比例应用共享权重，并将有关文档的信息聚合为1024长度的向量。 </li><li>master network，该网络使用inspector的输出为输入，进行最终分类决策。</li></ul><h5 id="Feature-extraction模块："><a href="#Feature-extraction模块：" class="headerlink" title="Feature extraction模块："></a>Feature extraction模块：</h5><p>原始数据为HTML文档，使用正则（[^\x00-\x7F]+|\w+）对文档进行分割，这个正则表达式的意思是匹配除了ASCII值从0-127的字符外的字符或者匹配包括下划线的任何单词字符（等价于’[A-Za-z0-9_]’）二者之一。简单说就是去掉了大部分标点符号。</p><p>我们将token流分成16个等长的连续块，其中每个块的长度定义为token数，如果文档中的令牌数不能被16整除，则最后一个块中的token数会比其他块少。</p><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/TokenizeChunk.png" alt></p><p>最后使用散列方法，将每个token块散列到1024个分区，16个块则表示为16X1024的向量，该向量表示一个HTML文档的词袋样式的token。</p><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/TokenizeLengthHash.png" alt></p><h5 id="Inspector模块："><a href="#Inspector模块：" class="headerlink" title="Inspector模块："></a>Inspector模块：</h5><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/inspector.png" alt></p><p>将16个token块分成8份、4份、2份、1份四个不同大小。一共就是31个token块。Inspector具有两个全连接层，每层具有1024个ReLU单元，使用归一化来防止梯度消失，dropout设置为0.2。经过上述过程，31个块每个都输出为1024维的向量，过最大池化得到一个输出。</p><h5 id="Master模块："><a href="#Master模块：" class="headerlink" title="Master模块："></a>Master模块：</h5><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/master.png" alt></p><p>最后一层是26个Sigmoid函数，其中1个用于判断该Web是否为恶意，其余25个用于判断具体类别。</p><h2 id="三、实验"><a href="#三、实验" class="headerlink" title="三、实验"></a>三、实验</h2><h3 id="3-1实验数据"><a href="#3-1实验数据" class="headerlink" title="3.1实验数据"></a>3.1实验数据</h3><p>作者使用从威胁情报站点VirusTotal收集的数据。VirusTotal每天接收数万个新的HTML文件，使用来自数十家安全供应商的60个Web威胁扫描程序扫描它们。 作者所在的Sophos公司订阅了VirusTotal的付费威胁情报服务，会收到提交给VirusTotal的每个HTML文件及其相应的扫描结果。本文中使用的实验数据集是在2017年前10个月从VirusTotal Feed中收集的。</p><p>训练/测试划分是根据文件在VirusTotal上首次报告的时间计算的。此过程确保</p><ul><li>训练和测试集是不同的</li><li>训练和测试过程近似于实际的部署方案</li></ul><p>数据的标签是从扫描器的综合结果得出，标记规则为：</p><ul><li>Benign: receiving 0 detections from security vendors</li><li>Malicious: receiving 3 or more detections</li><li>Indeterminate: received 1 or 2 detections, and did not use them</li></ul><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/dataset.png" alt></p><p>这种标记方法带来的弊端是只会简单地记住安全厂商产品已经能检测出恶意web内容的知识，而不是学习新的检测功能，以检测厂商社区可能会错过的恶意软件。 </p><p>实验将9月1日之前的数据用于训练，9月1日之后的数据用于测试。这样切分数据集有助于减轻供应商社区可能会错过的恶意Web内容的能力的问题。这是因为使用的测试集是训练集中未见过的文件。为了证明提出的方法的有效性，作者还手动检查了样本，标签为良性，但是将其分配为恶意的可能性很高，即误报率较高，他们发现这些假阳性文件中的大多数都明显是恶意或垃圾内容。</p><h3 id="3-2实验步骤"><a href="#3-2实验步骤" class="headerlink" title="3.2实验步骤"></a>3.2实验步骤</h3><p>作者进行了五个对比实验，其中三个测试了本文的方法相对于其他模型的有效性，剩下两个探索了模型的内部工作原理。</p><h4 id="三个测试模型有效性的对比实验："><a href="#三个测试模型有效性的对比实验：" class="headerlink" title="三个测试模型有效性的对比实验："></a>三个测试模型有效性的对比实验：</h4><ul><li>LR-BoT：Elastic Net regularized logistic regression on bag of token features.</li><li>FF-BoT：A feed-forward architecture using the 16284-length feature hashed bag of tokens feature representation used above. </li><li>XGBoost-BoT：A gradient boosted decision tree (XG-Boost) model using the same feature input as FF-BoT.</li></ul><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/ROC1.png" alt></p><h4 id="两个验证模型内部结构对实验结果的影响的对比实验："><a href="#两个验证模型内部结构对实验结果的影响的对比实验：" class="headerlink" title="两个验证模型内部结构对实验结果的影响的对比实验："></a>两个验证模型内部结构对实验结果的影响的对比实验：</h4><ul><li>FlatSequential：删除了平均池化步骤，即在输入到Inspector模型的31个聚合表示中，该模型只使用了最初的16个连续块。该对比模型检验了使用不同层次规模的文档对检测结果的准确率有所提升。</li><li>FlattenedFF：使用相同的特征表示，但没有Inspector模块，即没有应用共享权重，而是简单地将16x1024的token向量的转换为单个16384长的向量，并将其输入到前馈神经网络中，使用单独权重。该对比模型检验了共享权重对检测结果的准确率有所提升。</li></ul><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/ROC2.png" alt></p><h3 id="3-3实验结果"><a href="#3-3实验结果" class="headerlink" title="3.3实验结果"></a>3.3实验结果</h3><p>作者提出的方法误报率为0.1%，ROC曲线为97.5%，对小规模的网页能以每秒超过100条的速度进行分类，能够检测到安全社区遗漏的未知恶意Web内容。进一步地，对不同恶意家族也能进行区分，对XSS注入、浏览器漏洞利用和iFrame操纵攻击检测结果突出，但对钓鱼网站的表现最差。<br><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/family.png" alt></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>文章没有使用常规的词袋模型用于提取数据特征，而是使用hash对原始HTML文档进行处理，并考虑了不同层次规模大小的划分，以往的研究多是直接使用一个整体，没有考虑局部的一些特征，这也许会错过有效信息导致检测结果的偏差。这篇文章的对数据的处理这块想法新颖，不过模型训练部分属于常规操作，实验结果表现良好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一种快速、不区分格式的检测恶意Web内容的深度学习方法&quot;&gt;&lt;a href=&quot;#一种快速、不区分格式的检测恶意Web内容的深度学习方法&quot; class=&quot;headerlink&quot; title=&quot;一种快速、不区分格式的检测恶意Web内容的深度学习方法&quot;&gt;&lt;/a&gt;一种快速、
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://herasu.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web security" scheme="https://herasu.github.io/tags/web-security/"/>
    
      <category term="deep learning" scheme="https://herasu.github.io/tags/deep-learning/"/>
    
      <category term="IEEE SPW 2018" scheme="https://herasu.github.io/tags/IEEE-SPW-2018/"/>
    
      <category term="Web Content Detection" scheme="https://herasu.github.io/tags/Web-Content-Detection/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04 python2安装第三方库murmur</title>
    <link href="https://herasu.github.io/2019/10/22/ubuntu16.04%20python2%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93murmur/"/>
    <id>https://herasu.github.io/2019/10/22/ubuntu16.04 python2安装第三方库murmur/</id>
    <published>2019-10-22T10:53:24.734Z</published>
    <updated>2019-10-22T10:53:11.013Z</updated>
    
    <content type="html"><![CDATA[<p>复现代码时遇到的问题（实在不懂都9102了还用2009最后更新的库，而且还是py2!!!）</p><p>首先 <a href="https://pypi.org/project/Murmur/" target="_blank" rel="noopener">Murmur 0.1.3</a> 是用C++写的，</p><p>直接pip install murmur或者把源码下到本地用<figure class="highlight"><figcaption><span>setup.py build```也是一样的。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">缺少C++环境，[可以在此下载](https://www.microsoft.com/en-us/download/confirmation.aspx?id=44266)</span><br></pre></td></tr></table></figure></p><p>error: Microsoft Visual C++ 9.0 is required…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">装好环境之后再执行，缺少zlib.h库</span><br></pre></td></tr></table></figure></p><p>murmur/include\unzip.h(53) : fatal error C1083: Cannot open include file: ‘zlib.h’: No such file or directory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">所以还是要下源码= =!</span><br><span class="line">于是把zlib.h继续下到本地放进源码正确的位置中，后续还是出现了很多问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/herasu/blog_pic/master/error.png)</span><br><span class="line"></span><br><span class="line">最终解决办法：</span><br><span class="line">1. 在murmur/include/crypt.h开头添加两句</span><br></pre></td></tr></table></figure></p><p>#ifndef __MURMUR_CRYPT_H</p><p>#define __MURMUR_CRYPT_H<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/herasu/blog_pic/master/addtwolines.png)</span><br><span class="line"></span><br><span class="line">最后添加endif</span><br><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/herasu/blog_pic/master/endif.png)</span><br><span class="line"></span><br><span class="line">2. 再下载一个zlib.h</span><br></pre></td></tr></table></figure></p><p>apt install zlib1g-dev<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/herasu/blog_pic/master/apt.png)</span><br><span class="line"></span><br><span class="line">3. 就可以安装了！</span><br></pre></td></tr></table></figure></p><p>python setup.py build<br>python setup.py install<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复现代码时遇到的问题（实在不懂都9102了还用2009最后更新的库，而且还是py2!!!）&lt;/p&gt;
&lt;p&gt;首先 &lt;a href=&quot;https://pypi.org/project/Murmur/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Murmur 
      
    
    </summary>
    
      <category term="日常踩坑" scheme="https://herasu.github.io/categories/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="python" scheme="https://herasu.github.io/tags/python/"/>
    
      <category term="无法安装库" scheme="https://herasu.github.io/tags/%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>win10控制面板-系统和安全-系统 加载页面失败</title>
    <link href="https://herasu.github.io/2019/09/07/%E7%B3%BB%E7%BB%9Fwin10%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF-%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AE%89%E5%85%A8-%E7%B3%BB%E7%BB%9F%20%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E5%A4%B1%E8%B4%A5/"/>
    <id>https://herasu.github.io/2019/09/07/系统win10控制面板-系统和安全-系统 加载页面失败/</id>
    <published>2019-09-07T14:53:23.433Z</published>
    <updated>2019-10-09T11:45:45.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>之前电脑突然没法正常使用打印机了，就重装打印机驱动，每次装到最后步骤了总是弹出安装失败，无法安装的，也给了错误代码，于是顺着这个代码找解决办法，先是查看关于打印的有个服务Print Spooler总是自己自动关闭了又自己启动，尽管已经设置为自动启动，各种重新启动还是有这个问题，然后又照着网上的<a href="https://www.techsupportall.com/print-spooler-is-not-running/" target="_blank" rel="noopener">各种方法</a>查看注册表删除文件夹什么都试过了，删掉设备中打印机和扫描仪再重新添加，依然没有效果。</p><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/720b6cbaly1g6oi2vfjq7j20j801w74c.jpg" alt="image"></p><p>原本默认就是自动启动的，但在当前页刷新每隔一段时间它就自己关闭了。</p><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/720b6cbaly1g6ohzw32fxj20gi0500t5.jpg" alt="image"></p><p>经过与小伙伴的注册表和Print Spooler服务属性对比，注册表没有不同，就是Print Spooler服务属性中的依存关系小伙伴有RPC</p><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/720b6cbaly1g6ohylxmkzj20di0gtn0h.jpg" alt="image"></p><p>我这是灰色的什么都没有，问题应该就出在这，然而不知道咋整，想着什么时候重装系统应该就好了（反正重装就完事了hhhhhh）。</p><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>首先肯定是想打印个东西都需要别人帮忙，连带着有道云笔记中markdown通过打印转pdf也失效了，word中打印甚至打印机那里直接显示的是“未安装打印机”。</p><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/720b6cbaly1g6ohz50z41j20el0d1q37.jpg" alt="image"></p><p>其次我发现经过一顿胡乱操作后，文件系统还经常卡死，包括登录微信反应很久然后直接结束应用程序，非常不方便，强烈怀疑是连带问题。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>直到有一天！要添加个环境变量，结果打开系统加载不出，去找原因找到下面这篇 <a href="https://blog.csdn.net/sunshineddmmz/article/details/79506844" target="_blank" rel="noopener">博客</a> 和我遇到的情况一样，照着做了以后截成功了!<br>没想到的是，打印机也恢复如初，使用软件也不会动不动就结束应用程序了~</p><p><img src="https://raw.githubusercontent.com/herasu/blog_pic/master/720b6cbaly1g6oi2k8yjmj20c20ckq3h.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;之前电脑突然没法正常使用打印机了，就重装打印机驱动，每次装到最后步骤了总是弹出安装失败，无法安装的，也给了错误代码，于是顺着这个代码找解决办
      
    
    </summary>
    
      <category term="日常踩坑" scheme="https://herasu.github.io/categories/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="系统加载页面失败" scheme="https://herasu.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E5%A4%B1%E8%B4%A5/"/>
    
      <category term="打印机无法安装" scheme="https://herasu.github.io/tags/%E6%89%93%E5%8D%B0%E6%9C%BA%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Web中的点击拦截研究</title>
    <link href="https://herasu.github.io/2019/09/07/Web%E4%B8%AD%E7%9A%84%E7%82%B9%E5%87%BB%E6%8B%A6%E6%88%AA%E7%A0%94%E7%A9%B6/"/>
    <id>https://herasu.github.io/2019/09/07/Web中的点击拦截研究/</id>
    <published>2019-09-07T14:53:09.383Z</published>
    <updated>2019-09-08T05:34:33.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web中的点击拦截研究"><a href="#Web中的点击拦截研究" class="headerlink" title="Web中的点击拦截研究"></a>Web中的点击拦截研究</h1><p><strong>原文作者</strong>：Mingxue Zhang, Wei Meng, Sangho Lee, Byoungyoung Lee ,Xinyu Xing</p><p><strong>原文标题</strong>：All Your Clicks Belong to Me: Investigating Click Interception on the Web</p><p><strong>原文会议</strong>：Proceedings of the 28th USENIX Security Symposium (USENIX Security), Santa Clara, US, August 2019.</p><p><strong>原文链接</strong>：<a href="https://www.usenix.org/system/files/sec19fall_zhang_prepub.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/sec19fall_zhang_prepub.pdf</a></p><p>用户与Web应用交互主要通过点击事件，那么web中广告投放也不会放过拦截用户点击行为以获取利益。文章系统地研究了Web中的点击拦截实例，开发了一个基于浏览器的分析框架OBSERVER，用于收集和分析与点击相关的行为。文章作者使用OBSERVER，确定了三种不同的技术来拦截Alexa前250K网站上的用户点击，并检测到613个网站上437个截取用户点击的第三方脚本，这些网站平均每天可收到4300万次访问。通过拦截用户点击行为不仅是投放广告获利的手段之一，拦截用户点击行为还会让用户接触到诸如诈骗软件等恶意内容。</p><h2 id="作者的工作："><a href="#作者的工作：" class="headerlink" title="作者的工作："></a>作者的工作：</h2><p>作者基于开源Web浏览器Chromium，开发了一个框架OBSERVER，该框架可以识别出web应用中点击劫持行为，用户在使用web应用时对此类恶意行为的重视。整篇文章作者对研究背景进行描述总结，详细阐述了关键技术方法、实现与评估，同时还有局限性思考和未来相关工作的总结。</p><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>点击HTML元素是用户与Web应用程序交互的主要方式。已知的用户劫持点击行为包括<strong>UI redressing attacks</strong>，还有利用<strong>bots to automatically and massively send fake click traffic</strong>，用来点击广告获取利益，当这些行为已不再有效时，攻击者就盯上了重定向用户的点击。例如，“浏览者重定向病毒” 将用户的默认搜索引擎修改为恶意搜索引擎，当用户点击搜索结果时将用户重定向到广告页面。恶意第三方iframe可以自动将用户重定向到广告页面，当脚本在点击时打开新tab时，用户的当tab可以自动重定向到非预期目标页。谷歌最近发布了新版Chrome浏览器，以阻止某些特定类型的自动重定向。尽管如此，Chrome仍然无法检测并阻止其他可能的方法来拦截用户点击，包括但不限于由第三方脚本修改的链接，伪装成第一方内容的第三方内容以及透明覆盖等恶意行为。</p><h3 id="1-1-措施"><a href="#1-1-措施" class="headerlink" title="1.1 措施"></a>1.1 措施</h3><p>作者认为有必要对点击拦截进行系统研究，以深入了解这一新出现的网络用户威胁。因此开发一个系统，以自动检测Web上的此类实例，并研究哪些技术是被用来劫持用户点击以及发起这种行为的人。</p><p>文章结构安排：首先设计和开发一个系统来检测JavaScript用来拦截用户点击的各种技术。然后，作者使用这个系统进行大规模测量，目的是找出那些劫持链接并欺骗用户点击的从业者。最后，作者分析测量结果，并探索隐藏在点击拦截实践背后的意图和后果。</p><h3 id="1-2-挑战"><a href="#1-2-挑战" class="headerlink" title="1.2 挑战"></a>1.2 挑战</h3><p>由于Web应用程序的动态和事件驱动特性，执行上述系统研究具有挑战性。</p><p>1，可以动态加载JS代码。只对HTML源代码静态分析是无法涵盖拦截用户点击的所有脚本。</p><p>2，超链接可以由任何脚本动态创建和修改。为了确定一个脚本是否真正可以用于拦截，需要重新设计浏览器以区分不同脚本运行时的操作。</p><p>3，JS可以通过事件侦听器（handlers）动态地将URL绑定到任意HTML元素。</p><p>4，网页可能包含大量响应用户点击的事件处理程序。</p><h3 id="1-3-应对"><a href="#1-3-应对" class="headerlink" title="1.3 应对"></a>1.3 应对</h3><p>通过四个步骤对一个网站的所有可能涉及到劫持点击行为的地方的相关属性进行记录。</p><p>首先，在浏览器的渲染器中调解网页中JavaScript对超链接的所有访问。<br>通过这种方式可以识别与每个超链接关联的URL的发起者。</p><p>其次，监视JavaScript对象的创建和执行，以便我们可以追踪动态内联JS代码。</p><p>第三，监视所有在每个HTML元素上注册的事件处理程序以及与导航相关的JS API。</p><p>最后，导出导航网址。</p><h3 id="1-4-贡献"><a href="#1-4-贡献" class="headerlink" title="1.4 贡献"></a>1.4 贡献</h3><p>•作者设计和开发OBSERVER，一个研究点击拦截实践的框架。这有助于我们自动检测各种网站上的各种点击拦截案例。</p><p>•作者进行了大规模测量研究，以探索和了解攻击者如何在实际环境中操纵网页拦截用户点击。 </p><p>•作者描述了Alexa 前250K网站上点击拦截的活动，并发现了点击截取行为背后隐藏的意图和后果。</p><h2 id="二、框架概要"><a href="#二、框架概要" class="headerlink" title="二、框架概要"></a>二、框架概要</h2><p>在本节中，我们首先概述了OBSERVER框架，旨在全面记录JS代码执行的所有潜在点击拦截相关事件。关注三类JS会使用的基本操作劫持用户点击行为：</p><p>1）修改页面中的现有超链接; </p><p>2）在页面中创建新的超链接; </p><p>3）向HTML元素注册事件处理程序以挂钩用户点击。</p><p>每当OBSERVER识别出任何此类操作时，它都会使用启动操作的脚本的唯一标识来标记相应的元素。 此外，OBSERVER记录在故意点击与页面中的事件处理程序相关联的超链接或元素之后的反应，以便知道点击拦截后引导用户去向哪个URL。</p><h3 id="2-1-威胁模型"><a href="#2-1-威胁模型" class="headerlink" title="2.1 威胁模型"></a>2.1 威胁模型</h3><p>作者只考虑第三方JS脚本为恶意的，因为第一方对页面有完全的控制权。</p><h3 id="2-2-记录对网页中所有超链接的任何访问"><a href="#2-2-记录对网页中所有超链接的任何访问" class="headerlink" title="2.2 记录对网页中所有超链接的任何访问"></a>2.2 记录对网页中所有超链接的任何访问</h3><p>在HTML中，使用锚元素（即，<code>&lt;a&gt;</code> 标签）来定义超链接，并且其href属性值为目标URL。因此，通过监视和记录哪个脚本修改了 <code>&lt;a&gt;</code> 标签的href属性，OBSERVER能够识别脚本的潜在点击拦截。不论是直接使用原生JS修改href属性值还是利用JQ等第三方库修改，OBSERVER都可以识别到，因为这些方式仍然需要调用DOM标准中定义的上述API，这是由所有浏览器实现的，以确保跨浏览器的兼容性。具体方式是OBSERVER hook所有这些DOM API，以监视DOM中 <code>&lt;a&gt;</code> 标签的href属性的修改。它拦截对这些API的任何调用。截获后，它会检查当前的JS调用堆栈，再在调用堆栈中找到底部JS框架，以找到发起API调用的JS函数。</p><h4 id="2-2-1-脚本识别"><a href="#2-2-1-脚本识别" class="headerlink" title="2.2.1 脚本识别"></a>2.2.1 脚本识别</h4><p>在上个步骤找到了发起API调用的JS函数后，要将该API调用归于特定脚本，需要获取访问JS代码的标识。 OBSERVER为每个脚本对象分配一个scriptID，以便在JS运行时唯一地标识它。</p><p>在HTML中，JS代码常以三种方式引入：</p><ul><li>作为内联脚本包含在 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标记之间。</li><li>存储在外部JavaScript文件夹中，并作为外部脚本加载 <code>&lt;script&gt;</code> 标记。</li><li>JavaScript代码可以作为事件监听器写入HTML元素。</li></ul><p>每个 <code>&lt;script&gt;</code> 标签都编译为JavaScript引擎中的单个JavaScript对象。还有其他类型的内联JavaScript代码。例如，JavaScript代码可以作为事件监听器写入HTML元素的贡献。未包含在<br><code>&lt;script&gt;</code> 标签内的内联脚本也会编译为单独的JavaScript对象，这些对象由唯一的scriptID标识。</p><p>OBSERVER将脚本的scriptID与其sourceURL相关联，sourceURL是浏览器用于加载远程JavaScript代码的URL。但内联脚本的sourceURL为空，那么就使用浏览器用于将HTML文档加载到嵌入框架中的URL作为静态内联脚本的sourceURL。对于通过JavaScript创建内联脚本的情况将在之后讨论。除了scriptID之外，我们还在与元素关联的shadow数据存储中记录函数的行号，列号和名称。值得注意的是，JavaScript代码无法修改shadow数据存储，因为它是一个在JavaScript端不可写的C++数据结构。</p><h3 id="2-3-追踪动态元素创建"><a href="#2-3-追踪动态元素创建" class="headerlink" title="2.3 追踪动态元素创建"></a>2.3 追踪动态元素创建</h3><p>在网页中动态创建新的超链接是拦截用户点击的另一种方法。OBSERVER考虑了脚本可以实现此目标的直接和间接方法：1）创建超链接，2）创建 创建超链接的脚本。</p><h4 id="2-3-1-直接方式–HTML锚元素"><a href="#2-3-1-直接方式–HTML锚元素" class="headerlink" title="2.3.1 直接方式–HTML锚元素"></a>2.3.1 直接方式–HTML锚元素</h4><p>JavaScript代码可以在网页中动态创建任何HTML元素，包括锚元素。</p><p>具体来说，JavaScript可以通过多种API将新的 <code>&lt;a&gt;</code> 标签插入到网页的DOM树中。利用这些技术可以拦截用户点击。</p><p>OBSERVER需要跟踪浏览器中 <code>&lt;a&gt;</code> 标签的动态创建。 OBSERVER将shadow initiator属性附加到DOM树中的每个锚元素，以表示对象的创建者。 initiator属性值是创建相应元素的脚本的scriptID。OBSERVER为浏览器解析器构建的所有静态元素分配一个特殊的initiator值O，它表示文档的所有者。静态 <code>&lt;a&gt;</code> 标签是第一方超链接。 OBSERVER拦截Web浏览器中的所有元素创建API，以便找到调用堆栈中的JavaScript框架。发起创建行为的脚本的scriptID用作动态创建的元素（超链接）的启动器。OBSERVER还会记录动态创建的锚元素的任何对href的访问。</p><h4 id="2-3-2-间接方式–JS脚本"><a href="#2-3-2-间接方式–JS脚本" class="headerlink" title="2.3.2 间接方式–JS脚本"></a>2.3.2 间接方式–JS脚本</h4><p>JavaScript代码也可以在Web应用程序中动态生成，就像HTML元素一样。 <code>&lt;script&gt;</code> 作为一个HTML元素类，可以由JavaScript动态创建。OBSERVER旨在为所有这些动态创建的脚本分配唯一标识。如果将外部脚本文件从远程主机加载到动态插入的 <code>&lt;script&gt;</code> 元素中，则获取其标识与获取一个静态 <code>&lt;script&gt;</code> 元素的sourceURL没有区别。</p><p>但是，识别动态生成的内联脚本的标识并不简单，因为它的sourceURL是空白的。为了克服这种困难，OBSERVER hook用于生成动态脚本的API。它将调用脚本生成API的JavaScript代码的sourceURL保存为新生成的内联脚本的sourceURL。OBSERVER记录父脚本的scriptID作为子脚本的parentScriptID属性。最初由文档所有者静态嵌入的所有脚本的parentScriptID设置为O。OBSERVER还记录对任何DOM对象的任何内联事件处理程序的所有访问，它遍历所有脚本，将内联事件处理程序设置为其父脚本，并从中得到sourceURL。</p><p>如果找不到这样的条目，OBSERVER会将创建接收者对象的脚本设置为其父脚本。</p><h3 id="2-4-监控JavaScript事件监听器"><a href="#2-4-监控JavaScript事件监听器" class="headerlink" title="2.4 监控JavaScript事件监听器"></a>2.4 监控JavaScript事件监听器</h3><p>不需要修改或创建一个超链接，直接监听现有的HTML元素上的事件侦听器也能达到一样的效果。事件侦听器的作用是当用户点击已绑定侦听器的元素时，会触发该事件，事件处理程序则异步执行一些操作。也许是任意打开一个URL或者悄悄地发起某些请求。于是OBSERVE旨在监控这些事件侦听器看看是否会导航用户到不同的URL去。</p><h3 id="2-5-视觉欺骗"><a href="#2-5-视觉欺骗" class="headerlink" title="2.5 视觉欺骗"></a>2.5 视觉欺骗</h3><p>作者确定了两种可能的视觉欺骗：模仿和透明叠加。<br>都是字面意思，模仿就是弄一个和真实网站中部分内容类似的，使用户不仔细看以为是正常的就去点击；透明叠加是将恶意内容覆盖到原本正常内容之上，修改透明度使用户不易察觉。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1g5t87zprgpj20kh0dc78f.jpg" alt></p><p>例如左边黄色线框内，小字是sponsored，与上下红色框做得很像，诱使用户点击。<br>右边青色线框标记的全是第三方内容，由于覆盖在第一方内容之上，用户无论点哪都会触发第三方脚本预先设定好的点击事件。</p><h3 id="2-6-部署"><a href="#2-6-部署" class="headerlink" title="2.6 部署"></a>2.6 部署</h3><p>Chromium browser (version 64.0.3282.186)</p><h2 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h2><h3 id="3-1-数据集"><a href="#3-1-数据集" class="headerlink" title="3.1 数据集"></a>3.1 数据集</h3><p>Alexa前250K网站。有效网站为228,614个。</p><p>两个步骤获取数据：1）在页面渲染后立即收集原始数据; 2）通过与渲染页面交互来收集反应数据。 首先OBSERVER等待最多45秒，是为了让浏览器完全呈现页面。</p><p>之后，在页面中插入一个脚本以预先遍历DOM树，以收集OBSERVER已记录的每个元素的所有数据，还记录每个元素的几个显示属性（宽度，高度，位置，不透明度等），以研究可用于拦截用户点击的其他技巧（例如，某些第三方内容与之重叠或出现 类似于第一方内容）。</p><p>然后，将当前DOM树的快照保存到外部HTML文件夹中。通过Selenium自动点击DOM树中的所有元素，触发click事件侦听器和超链接导航以收集导航日志。</p><h3 id="3-2-第三方脚本检测"><a href="#3-2-第三方脚本检测" class="headerlink" title="3.2 第三方脚本检测"></a>3.2 第三方脚本检测</h3><p>由于作者认定第一方脚本具有高度完全的权力去操控任意元素，所以其行为不被认定为攻击，识别出第三方脚本就至关重要。主要通过判定该网站所属域以及加载的各个脚本所属域是否是同一组织或个人。该判断并不是100%准确的。</p><h3 id="3-3-拦截检测"><a href="#3-3-拦截检测" class="headerlink" title="3.3 拦截检测"></a>3.3 拦截检测</h3><p>对三种方式（超链接、事件侦听器、视觉欺骗）进行拦截点击的方法第二节描述过。</p><h3 id="3-4-逃避检测"><a href="#3-4-逃避检测" class="headerlink" title="3.4 逃避检测"></a>3.4 逃避检测</h3><p>一些第三方脚本有选择地拦截用户点击。通过限制拦截点击的速度，避免用户的怀疑。还有些脚本仅在用户第一次访问页面时才会在其事件处理程序中激活相关的代码。这可以通过在用户的浏览器中删除cookie来实现。</p><h3 id="3-5-实验结果"><a href="#3-5-实验结果" class="headerlink" title="3.5 实验结果"></a>3.5 实验结果</h3><h4 id="3-5-1-第三方脚本识别"><a href="#3-5-1-第三方脚本识别" class="headerlink" title="3.5.1 第三方脚本识别"></a>3.5.1 第三方脚本识别</h4><p>三大类技术，分别是超链接、事件处理器、视觉欺骗。<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1g5t7p3c6iwj20je0ckgne.jpg" alt></p><h4 id="3-5-2-第三方代码加载方式"><a href="#3-5-2-第三方代码加载方式" class="headerlink" title="3.5.2 第三方代码加载方式"></a>3.5.2 第三方代码加载方式</h4><p>从下表可以看出，由第一方脚本静态引入第三方脚本是最常用的方法。<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1g5t7r0n9jhj20jx06u3z8.jpg" alt></p><h3 id="3-6-点击拦截缘由与影响"><a href="#3-6-点击拦截缘由与影响" class="headerlink" title="3.6 点击拦截缘由与影响"></a>3.6 点击拦截缘由与影响</h3><ol><li>盈利，主要是广告与欺骗用户点击广告。</li><li>传播恶意内容，自动下载恶意软件等。</li></ol><h2 id="四、讨论与将来工作"><a href="#四、讨论与将来工作" class="headerlink" title="四、讨论与将来工作"></a>四、讨论与将来工作</h2><p>作者从第三方脚本识别、检测范围（网站数量）、区分真实点击与自动化测试软件的模拟点击、生成安全警告与使浏览器自动执行一些策略来防止点击被拦截五个方面来讨论。</p><p>第三方脚本识别问题作者是使用了域名作为判断依据，如何判断不同脚本来自同一个域比较复杂，感兴趣的可以看看原文。</p><p>检测范围是Alexa前250K个网站的主页面，子页面没有检测。</p><p>作者使用了selenium去驱动OBSERVE与网站进行交互，但是区分真实点击与这种自动化工具生成的模拟点击也是一个研究方向。</p><p>已知存在这种安全威胁后，作者提出两点进行防御，一是生成安全警告让用户决定是否继续访问，二是安全策略确保链接与点击为整体，不会被任何第三方脚本修改。</p><h2 id="五、思考"><a href="#五、思考" class="headerlink" title="五、思考"></a>五、思考</h2><p>从最后作者提出的几个待解决的问题来说，到目前为止没有很好的方法去解决，我们可以沿着这些思路继续研究下去。作者的工作量很大，涵盖的点击事件可能性全面，只是有些点击行为较为主观不好定义为是正常的还是恶意的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web中的点击拦截研究&quot;&gt;&lt;a href=&quot;#Web中的点击拦截研究&quot; class=&quot;headerlink&quot; title=&quot;Web中的点击拦截研究&quot;&gt;&lt;/a&gt;Web中的点击拦截研究&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;原文作者&lt;/strong&gt;：Mingxue Zhan
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://herasu.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web security" scheme="https://herasu.github.io/tags/web-security/"/>
    
      <category term="USENIX 2019" scheme="https://herasu.github.io/tags/USENIX-2019/"/>
    
      <category term="Click Interception" scheme="https://herasu.github.io/tags/Click-Interception/"/>
    
  </entry>
  
  <entry>
    <title>踩坑小结3</title>
    <link href="https://herasu.github.io/2019/06/12/%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%933/"/>
    <id>https://herasu.github.io/2019/06/12/踩坑小结3/</id>
    <published>2019-06-12T13:53:23.532Z</published>
    <updated>2019-06-12T13:53:11.727Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-路由传参undefined？"><a href="#1-路由传参undefined？" class="headerlink" title="1.路由传参undefined？"></a>1.路由传参undefined？</h4><p>上一节已经区分过两种传参方式，仍然在踩坑路上越走越远</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let routeData = this.$router.resolve(&#123; name: &apos;xxx&apos;, params: &#123; id: id &#125;&#125;)</span><br><span class="line">window.open(routeData.href, &apos;_blank&apos;) //新开页面无法获取到id</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;name:&apos;xxx&apos;,params:&#123;id:id&#125;&#125;) //直接替换当前路由可获取到</span><br></pre></td></tr></table></figure><p> 问了师姐，她说是要用watch监听路由变化，监听出来就是第一种的from.path为根路由，并非是我跳转前的真实当前路由；第二种直接跳转的一切正常。暂时没想到既要新开页面，也希望用name和params传参的办法，先留个坑，之后再填。<br>不过用path和query传参虽然会显得URL比较丑，但能确保用户刷新后还有数据。</p><h4 id="2-v-bind绑定变量与字符串组合"><a href="#2-v-bind绑定变量与字符串组合" class="headerlink" title="2.v-bind绑定变量与字符串组合"></a>2.v-bind绑定变量与字符串组合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//xx为变量</span><br><span class="line"></span><br><span class="line">第一种</span><br><span class="line">:title=&quot;`字符串$&#123;xx&#125;`&quot;</span><br><span class="line">&lt;div :uid=&quot;props.row.id + &apos;one&apos;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">第二种</span><br><span class="line">:title=&quot;&apos;字符串&apos; + xx&quot;</span><br><span class="line">&lt;div :uid=&quot;`$&#123;props.row.id&#125;two`&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="3-父子组件通信传值"><a href="#3-父子组件通信传值" class="headerlink" title="3.父子组件通信传值"></a>3.父子组件通信传值</h4><p>父组件A从后端获取数据传给子组件B，子组件B使用父组件A传递过来的值C发起XHR请求数据，再将请求回来的数据用于渲染DOM，但是在发起请求时参数C值是undefined，说明没获取到父组件传递过来的值，在生命周期钩子created,mounted里都没有，但在开发时，若修改了别的地方保存时没有刷新这个值C便又有了，感到很疑惑，因为跟C同时获取回来的其他数据在父组件A中都可以直接使用，甚至不传给子组件，就在原父组件中使用C获取远程数据还是不行，感觉是因为需要使用C的请求异步触发的方法在C有值前就发起了，导致一个undefined。于是想到用watch监听C，逻辑上还是存在这个问题，但是功能实现了，子组件watch到C值后再发起一个请求。</p><h4 id="4-导出xlxs数据出错"><a href="#4-导出xlxs数据出错" class="headerlink" title="4.导出xlxs数据出错"></a>4.导出xlxs数据出错</h4><p>起初将从后台获取下载数据、转换格式和导出分为三部分。<br>每次下载数据从后台获取，数据较多需要较长时间，结果就导致数据还没取到就进行转换了，于是报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot convert undefined or null to object</span><br></pre></td></tr></table></figure><p>打印一下<strong>const data = this.formatJson(filterVal, response.data)</strong> 的data是有值的，数据格式也正确，但是发现先触发了<strong>export_json_to_excel()</strong>，而其参数data在被触发时还是空的，JS有时候这种异步真的让人崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">getdata()&#123;</span><br><span class="line">   let url = &apos;/api/getdata?id=1234&apos;</span><br><span class="line">   this.$axios.get(url).then(response =&gt; &#123;</span><br><span class="line">       this.downloadData=response.data</span><br><span class="line">   &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">exportExcel() &#123;</span><br><span class="line">    import(&apos;../vendor/Export2Excel&apos;).then(excel =&gt; &#123;</span><br><span class="line">        const tHeader = [&apos;id&apos;, &apos;name&apos;, &apos;phone-number&apos;, &apos;age&apos;];</span><br><span class="line">        const filterVal = [&apos;id&apos;, &apos;name&apos;, &apos;phonenumber&apos;, &apos;age&apos;];</span><br><span class="line">        this.getedata();</span><br><span class="line">        const data = this.formatJson(filterVal, this.downloadData);</span><br><span class="line">        excel.export_json_to_excel(&#123;</span><br><span class="line">            header: tHeader,</span><br><span class="line">            data,</span><br><span class="line">            filename: &apos;Results&apos;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formatJson(filterVal, jsonData) &#123;</span><br><span class="line">    return jsonData.map(v =&gt; filterVal.map(j =&gt; v[j]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为了确保axios完成后再转换，只得将其写到其中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">exportExcel() &#123;</span><br><span class="line">  var url = &apos;/api/getdata?id=1234&apos;</span><br><span class="line">  this.$axios.get(url).then(response =&gt; &#123;</span><br><span class="line">    import(&apos;../vendor/Export2Excel&apos;).then(excel =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">      const tHeader = [&apos;id&apos;, &apos;name&apos;, &apos;phone-number&apos;, &apos;age&apos;];</span><br><span class="line">      </span><br><span class="line">      const filterVal = [&apos;id&apos;, &apos;name&apos;, &apos;phonenumber&apos;, &apos;age&apos;];</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      const data = this.formatJson(filterVal, response.data)</span><br><span class="line">      </span><br><span class="line">      excel.export_json_to_excel(&#123;</span><br><span class="line">        header: tHeader,</span><br><span class="line">        data,</span><br><span class="line">        filename: &apos;Results&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">formatJson(filterVal, jsonData) &#123;</span><br><span class="line">  return jsonData.map(v =&gt; filterVal.map(j =&gt; v[j]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-上传文件"><a href="#5-上传文件" class="headerlink" title="5.上传文件"></a>5.上传文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upload(event) &#123;</span><br><span class="line">  if (this.inputFile) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    let data = new FormData(); //new FormData()很重要</span><br><span class="line">    data.append(&quot;input_file&quot;, this.inputFile)</span><br><span class="line">    //此处&quot;input_file&quot;要与后端定义的name相同</span><br><span class="line">    //不可写成 let data.input_file = this.inputFile</span><br><span class="line">    let headers = &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart/form-data&quot; &#125; &#125;</span><br><span class="line">    this.$axios.post(&quot;/api/upload&quot;, data, headers).then(response =&gt; &#123;</span><br><span class="line">                ...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;else if (!this.inputFile) &#123;</span><br><span class="line">    this.$message.error(&apos;Please Select a file...&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>同时要注意后端对上传文件格式做了过滤。</p><h4 id="6-打包拆分JS，引入CDN"><a href="#6-打包拆分JS，引入CDN" class="headerlink" title="6.打包拆分JS，引入CDN"></a>6.打包拆分JS，引入CDN</h4><p>一开始打包完有仅app.js都有3.几M，实在太大了，因为是中途改了需求，期初又用了bootstrap的静态模板，这点真的让人炸毛，随之带来的库（如jq）真的太大了，带宽就100KB/S，每次打开网页都需要至少半分钟，影响体验。</p><p>第一次考虑切分代码，尽管已经用了官方推荐的webpack路由懒加载方式，考虑到某些库只用在个别组件，便不在main.js中import，东删西删，连大部分注释都去掉了，也没有减少多少。感到绝望！</p><p><a href="https://blog.csdn.net/qq_37540004/article/details/78727063" target="_blank" rel="noopener">三种懒加载方式</a></p><ul><li>vue异步组件</li><li>es提案的import()</li><li>webpack的require.ensure() (推荐)</li></ul><p>既然懒加载效果也不明显，那就进入正题！先用 <strong>npm run build –report</strong> 查看各js占比。看了下占得较多的几个库，其中就有vue和elementUI，OK fine，把它们移出去，第一次打包上线ElementUI is not defined。</p><p>报错在这里 <strong>module.exports = ElementUI;</strong></p><p>原来不小心引入CDN时顺序错了，Vue要在ElementUI前引入，改了后以为这下总没问题了吧，结果还是找不到ElementUI，查了查说是</p><blockquote><p><a href="https://segmentfault.com/q/1010000009568751" target="_blank" rel="noopener">因为elementUI外部库对外暴露的全局变量是’ELEMENT’，引入其他外部库也是这样，必须填写外部库对外暴露的全局变量名。</a></p></blockquote><p>遇到一个问题，把整个ElementUI移出去了，但是想要使用其非中文的语言包，比如英语，只知道npm方式下如何在全局修改，如果同样要把locale 移除，在external中要怎么写？</p><h4 id="7-vue-cli3静态资源加载404"><a href="#7-vue-cli3静态资源加载404" class="headerlink" title="7.vue-cli3静态资源加载404"></a>7.vue-cli3静态资源加载404</h4><p>到最后打包完上线了，静态资源全部404，由于之前用vue-cli2所以每次改一下<br><strong>config&gt;index.js&gt;build:{… assetsPublicPath: ‘./‘, …}</strong></p><p>现在vue-cli3的文件结构有多区别，需要自行配置，根目录新建文件 <strong>vue.config.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    publicPath: &quot;./&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-路由传参undefined？&quot;&gt;&lt;a href=&quot;#1-路由传参undefined？&quot; class=&quot;headerlink&quot; title=&quot;1.路由传参undefined？&quot;&gt;&lt;/a&gt;1.路由传参undefined？&lt;/h4&gt;&lt;p&gt;上一节已经区分过两种传参方式
      
    
    </summary>
    
      <category term="前端" scheme="https://herasu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://herasu.github.io/tags/vue/"/>
    
      <category term="路由router" scheme="https://herasu.github.io/tags/%E8%B7%AF%E7%94%B1router/"/>
    
      <category term="父子组件通信" scheme="https://herasu.github.io/tags/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    
      <category term="上传文件" scheme="https://herasu.github.io/tags/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    
      <category term="导出xlsx" scheme="https://herasu.github.io/tags/%E5%AF%BC%E5%87%BAxlsx/"/>
    
      <category term="打包缩减JS" scheme="https://herasu.github.io/tags/%E6%89%93%E5%8C%85%E7%BC%A9%E5%87%8FJS/"/>
    
      <category term="静态资源404" scheme="https://herasu.github.io/tags/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90404/"/>
    
  </entry>
  
  <entry>
    <title>踩坑小结2</title>
    <link href="https://herasu.github.io/2019/04/16/%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%932/"/>
    <id>https://herasu.github.io/2019/04/16/踩坑小结2/</id>
    <published>2019-04-16T03:56:24.249Z</published>
    <updated>2019-04-16T03:55:27.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-路由"><a href="#1-路由" class="headerlink" title="1. 路由"></a>1. 路由</h2><h3 id="1-1-跳转页面"><a href="#1-1-跳转页面" class="headerlink" title="1.1 跳转页面"></a>1.1 跳转页面</h3><p>开发中遇到需要在函数中实现页面跳转时，一般会使用this.$router.push。</p><blockquote><p>使用 <router-link> 创建 a 标签来定义导航链接时，我们点击 <router-link> 时，这个方法会在内部调用，所以说，点击 <router-link :to="..."> 等同于调用 router.push(…)。</router-link></router-link></router-link></p></blockquote><p>那么若想要跳转时新开一个页面，而不是在原有页面中跳转，这时可以通过添加target=_blank属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link target=&quot;_blank&quot; :to=&quot;home&quot;&gt;新页面打开home页&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>编程式导航需要使用this.$router.resolve：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let routeData = this.$router.resolve(&#123; path: &apos;/home&apos;, query: &#123; id:id &#125;&#125;);</span><br><span class="line">window.open(routeData.href, &apos;_blank&apos;);</span><br></pre></td></tr></table></figure><h3 id="1-2-路由传参"><a href="#1-2-路由传参" class="headerlink" title="1.2 路由传参"></a>1.2 路由传参</h3><p>既然涉及到传参，也简单说明一下。<br>首先要清楚</p><blockquote><p>this.$router：VueRouter 实例，有一系列对应的方法：router.push、 router.replace 和 router.go等。</p><p>this.$route：当前激活的路由信息对象。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过你可以 watch (监测变化) 它，可以获取name、path、query、params等。</p></blockquote><p>vue-router传参一般使用的是query和params，分别介绍两种方式。</p><p><strong>1.2.1query方式传参和接收参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">传参: </span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">        path:&apos;/xxx&apos;,</span><br><span class="line">        query:&#123;</span><br><span class="line">          id:id</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  </span><br><span class="line">接收参数:</span><br><span class="line">this.$route.query.id</span><br></pre></td></tr></table></figure><p>如果提供了path，params会被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">        path: &apos;/xxx&apos;, </span><br><span class="line">        params: &#123; </span><br><span class="line">            id:id</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;) </span><br><span class="line">// 这里的 params 不生效</span><br></pre></td></tr></table></figure><p><strong>1.2.2params方式传参和接收参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">传参: </span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">        name:&apos;xxx&apos;,</span><br><span class="line">        params:&#123;</span><br><span class="line">          id:id</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  </span><br><span class="line">接收参数:</span><br><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure></p><p>手写完整的带有参数的 path：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; path: `/xxx/$&#123;id&#125;` &#125;)</span><br></pre></td></tr></table></figure><p>同样可以结合_blank新开页面传递参数，这里上面已经有示例了。</p><p>另外，使用query传参页面跳转的时候，可以在地址栏看到请求参数，而params传参时不会在地址栏中显示。</p><h3 id="1-3-路由模式"><a href="#1-3-路由模式" class="headerlink" title="1.3 路由模式"></a>1.3 路由模式</h3><p>最后还有一点，我觉得url上的#不好看想去掉于是设置了<strong>history模式</strong>，结果！！！！！跳转时新开页面报错404，在本地开发的时候没有问题，放到服务器上就报错，找了很久问题所在…………直到看了官方文档说是后端也需要配置，果然文档需要仔细看啊。以前觉得history就是用来去掉那个难看的#的，其实里面学问还挺多的。</p><h2 id="2-父子组件通信"><a href="#2-父子组件通信" class="headerlink" title="2. 父子组件通信"></a>2. 父子组件通信</h2><blockquote><p>父组件传入子组件的prop中的值是不允许改变的。</p></blockquote><p>我是在父组件传递给子组件分页的当前页currentPage时遇到的，翻页的时候会触发事件给父组件，父组件在自己的方法中改变后再传递给子组件，但是子组件也触发了修改currentPage的事件想要修改props中的值。</p><p>报错：[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop’s value. Prop being mutated: “currentPage” (found in component)</p><h3 id="2-1-中间变量"><a href="#2-1-中间变量" class="headerlink" title="2.1 中间变量"></a>2.1 中间变量</h3><p>一种方法用中间值替代：在data中使用一个中间变量，将其赋值为props的值，所有操作props值得地方都通过操作data中副本来实现，对父组件不做改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//父组件HTML</span><br><span class="line">&lt;TableData :tableData=&quot;tableData&quot; :currentPage.sync=&quot;currentPage&quot; :total=&quot;total&quot; :nextPage=&quot;nextPage&quot; @handleCurrentChange=&quot;handleCurrentChange&quot;&gt;&lt;/TableData&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//子组件HTML</span><br><span class="line">&lt;el-pagination @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;currentPage&quot; :page-size=&quot;10&quot; layout=&quot;total, prev, pager, next, jumper&quot; :total=&quot;total&quot;&gt;</span><br><span class="line">  &lt;/el-pagination&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--子组件JS--&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;TableData&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    pcurrentPage: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      currentPage:this.pcurrentPage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-sync修饰符"><a href="#2-2-sync修饰符" class="headerlink" title="2.2 .sync修饰符"></a>2.2 .sync修饰符</h3><p>还可以使用<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">.sync修饰符</a>：</p><p>再次说明，要好好读文档。</p><h2 id="3-filter与slot使用姿势"><a href="#3-filter与slot使用姿势" class="headerlink" title="3. filter与slot使用姿势"></a>3. filter与slot使用姿势</h2><p><a href="https://segmentfault.com/q/1010000015780925" target="_blank" rel="noopener">https://segmentfault.com/q/1010000015780925</a></p><blockquote><p>过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 `v-bind` 中 --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这次遇到的是对table中的某个单元格进行过滤，并定义点击事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column  prop=&quot;data&quot; label=&quot;data&quot; align=&quot;center&quot;&gt;</span><br><span class="line">    &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">      &lt;span @click=&quot;somethingtodo(scope.row)&quot;&gt;&#123;&#123;scope.row.data|replacena&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/el-table-column&gt;</span><br><span class="line">  </span><br><span class="line">methods:&#123;</span><br><span class="line">    somethingtodo(row) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;，</span><br><span class="line"></span><br><span class="line">filters: &#123;</span><br><span class="line">    replacena(value) &#123;</span><br><span class="line">        if(value==&apos;&apos;)&#123;</span><br><span class="line">            return &apos;空&apos;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在2.6.0中，我们为具名插槽和作用域插槽引入了一个新的统一的<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD" target="_blank" rel="noopener">语法</a>(即v-slot指令。它取代了slot和slot-scope这两个目前已被废弃但未被移除且仍在文档中的特性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-路由&quot;&gt;&lt;a href=&quot;#1-路由&quot; class=&quot;headerlink&quot; title=&quot;1. 路由&quot;&gt;&lt;/a&gt;1. 路由&lt;/h2&gt;&lt;h3 id=&quot;1-1-跳转页面&quot;&gt;&lt;a href=&quot;#1-1-跳转页面&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="前端" scheme="https://herasu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://herasu.github.io/tags/vue/"/>
    
      <category term="路由router" scheme="https://herasu.github.io/tags/%E8%B7%AF%E7%94%B1router/"/>
    
      <category term="父子组件通信" scheme="https://herasu.github.io/tags/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    
      <category term="插槽slot" scheme="https://herasu.github.io/tags/%E6%8F%92%E6%A7%BDslot/"/>
    
  </entry>
  
  <entry>
    <title>去除图片背景的在线网站</title>
    <link href="https://herasu.github.io/2019/04/03/%E5%8E%BB%E9%99%A4%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E7%9A%84%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99/"/>
    <id>https://herasu.github.io/2019/04/03/去除图片背景的在线网站/</id>
    <published>2019-04-03T11:57:53.979Z</published>
    <updated>2019-04-03T12:00:19.155Z</updated>
    
    <content type="html"><![CDATA[<p>最近有需求对证件照的背景颜色进行替换，发现了这么一个宝藏网站<a href="https://www.remove.bg/" target="_blank" rel="noopener">removebg</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>号称全自动（不必手动选择背景/前景层来分隔它们），无需一次点击，只需五秒就可得到！</p><blockquote><p>使用复杂的AI技术来检测前景层并将它们与背景分开。为了改善结果，有几个额外的算法，例如改善细节和防止颜色污染。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>官方支持两种加载图片方式: <strong>本地文件上传 or 图片URL地址</strong>，操作非常简单，除了去掉原背景外还可以添加新的背景，包括纯色或图片，图片可以选择自带提供的也可以使用自己上传的。</p><p>个人使用的话，免费版就完全够了，无需注册，注册后还有每个月50次API调用与一张HD图像免费下载资格。</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>支持最大文件大小为8 MB的JPG和PNG图像。每张图片必须包含至少一个可检测的人。</p><p>可以上传任何图像分辨率并选择以下输出尺寸之一，其中只有0.25百万像素是免费的。</p><table><thead><tr><th>画质</th><th>像素</th></tr></thead><tbody><tr><td>常规</td><td>高达0.25百万像素 - 例如625×400（free）</td></tr><tr><td>中等</td><td>高达1.5百万像素 - 例如1500×1000</td></tr><tr><td>高清</td><td>高达4百万像素 - 例如2500×1600 </td></tr><tr><td>4K</td><td>高达1000万像素 - 例如4000×2500</td></tr></tbody></table><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>API目前仅支持：人物照片；支持八种环境的API使用。</p><p>API是一个简单的HTTP接口，有各种选项：</p><ul><li>源图像：直接上传或URL引用 </li><li>结果图像：图像文件或JSON编码数据 </li><li>输出分辨率：高达1000万像素 </li></ul><p>需要带有人物的图像，还有三个关于PHP、NODEJS、PYTHON的社区。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该网站承诺（who knows）不会拿用户的照片用于训练，如果用户自愿给他们使用也可以。</p><p><strong>收费服务</strong>：相信大家用不上收费服务，这里可以直接看<a href="https://www.remove.bg/pricing" target="_blank" rel="noopener">官网</a>的价格套餐。</p><p>总的来说优点就是快，省事，简单，在线去背景，效果还不错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有需求对证件照的背景颜色进行替换，发现了这么一个宝藏网站&lt;a href=&quot;https://www.remove.bg/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;removebg&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;
      
    
    </summary>
    
      <category term="宝藏网站" scheme="https://herasu.github.io/categories/%E5%AE%9D%E8%97%8F%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="在线网站" scheme="https://herasu.github.io/tags/%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99/"/>
    
      <category term="实用" scheme="https://herasu.github.io/tags/%E5%AE%9E%E7%94%A8/"/>
    
      <category term="去背景" scheme="https://herasu.github.io/tags/%E5%8E%BB%E8%83%8C%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>踩坑小结</title>
    <link href="https://herasu.github.io/2019/02/28/%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%93/"/>
    <id>https://herasu.github.io/2019/02/28/踩坑小结/</id>
    <published>2019-02-28T13:04:48.932Z</published>
    <updated>2019-02-28T13:04:40.348Z</updated>
    
    <content type="html"><![CDATA[<p>最近实践开发中遇到一些小的问题，踩了不少坑，记录下来方便之后避免重复踩坑。</p><h1 id="vue兼容IE"><a href="#vue兼容IE" class="headerlink" title="vue兼容IE"></a>vue兼容IE</h1><blockquote><p>Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p></blockquote><h2 id="no-cli-webpack"><a href="#no-cli-webpack" class="headerlink" title="no cli/webpack"></a>no cli/webpack</h2><p>一开始没有使用vue-cli，只是单个的HTML文件，毕竟在Chrome下调试没有考虑到要兼容IE，对于非cli开发的暂时也没想到办法，试过直接引入babel-polyfill的cdn或是直接引入本地babel-polyfill也不行。后来考虑到用了ES6语法,而IE不支持ES6的特性。想到将ES6语法转换成ES5。</p><blockquote><p>Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。</p></blockquote><p>保险起见，使用browser.js（可转换不包含Promise等新的API的语法）与polyfill.js（确保API也能正常）。根据<a href="https://www.kancloud.cn/digest/babel/217110" target="_blank" rel="noopener">babel相关教程</a>进行修改，别忘记设置script里type=”text/babel”，解决了部分问题，比如在IE下页面显示部分，但还是没有显示全。注意ES6是强制strict模式的，遇到报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT1046: strict 模式下不允许一个属性有多个定义</span><br></pre></td></tr></table></figure><p>由于用了elementUI，里面有一些重复的属性，从功能上考虑还是不删更好。<br>折腾半天还是不行，就转向了cli下。如果有小伙伴解决了这个问题欢迎分享。</p><h2 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h2><p>在cli下开发就容易多了，按照网上查找的方法成功解决问题，记得npm装一下babel-polyfill</p><p>接着在build文件夹下的webpack.base.conf.js文件中修改entry，添加babel-polyfill</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    context: path.resolve(__dirname, &apos;../&apos;),</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &apos;./src/main.js&apos;, //将这行注释掉</span><br><span class="line">        app: [&quot;babel-polyfill&quot;, &quot;./src/main.js&quot;], //添加这行</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>然后在src文件夹下的main.js入口文件中引入 babel-polyfill</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;babel-polyfill&quot;</span><br></pre></td></tr></table></figure><p>此时测试在IE下打开效果，同时也让小伙伴帮忙测试，同样两个人都是IE11结果却是一个能打开一个打开一片空白。结果发现能正常访问其IE浏览器默认显示版本为IE8以上，不能正常访问的用户，其IE浏览器默认显示版本都在IE8以下。不能正常显示的IE浏览器默认选用的显示版本却是IE8及以下，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1g0m8eapcdej207207ldfn.jpg" alt></p><p>那么解决该问题的方法就是让IE浏览器的显示版本都要大于8，具体解决方法如下：</p><p>在项目的index.html文件的head中加入以下meta语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>这句话的意思就是告诉IE浏览器，IE8以上的版本都以最高版本来渲染页面。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1g0m8ehfcy1j207f07pweb.jpg" alt></p><hr><h1 id="vue中数据修改"><a href="#vue中数据修改" class="headerlink" title="vue中数据修改"></a>vue中数据修改</h1><p>vue里面的v-model是双向绑定，修改对象A的时候，引用该数据的地方也会随之更改，为了避免原对象A被修改，想用一个中间变量过渡一下，所以命名一个新的对象B，对象B和原始的对象A是一样的内容，只是名字不一样，<em>this.A=this.B</em>，但是赋值之后发现，修改中间对象B的属性值，原始对象A也会更改，原来是vue的对象赋值，没有进行深层赋值，只是把this.A的地址指向了与this.B相同的地址，所有对于A的修改会影响到B。解决相互影响的思路是在this.A必须是新建的一个对象，这样才能保证不被指向同一地址，属性修改不会相互影响。解决方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.A=JSON.parse(JSON.stringify(this.B));</span><br></pre></td></tr></table></figure><hr><h1 id="vue中渲染闪烁问题"><a href="#vue中渲染闪烁问题" class="headerlink" title="vue中渲染闪烁问题"></a>vue中渲染闪烁问题</h1><ul><li>使用了，一闪而过的双花括号，解决方案使用v-bind</li><li>使用了v-if/v-show，本应隐藏的元素先显示再隐藏的问题，造成了闪烁，解决办法在v-if所在元素中加上v-cloak</li></ul><p>在CSS中定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak]&#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="vue打包静态资源路径问题"><a href="#vue打包静态资源路径问题" class="headerlink" title="vue打包静态资源路径问题"></a>vue打包静态资源路径问题</h1><ol><li>config文件夹下下index.js中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">build: &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Paths</span><br><span class="line">    assetsRoot: path.resolve(__dirname, &apos;../dist&apos;),</span><br><span class="line">    assetsSubDirectory: &apos;static&apos;,</span><br><span class="line">    assetsPublicPath: &apos;./&apos;,   //加一个&quot;.&quot;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>若使用了iconfonts等库，还要在build文件夹下的utils.js中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (options.extract) &#123;</span><br><span class="line">      return ExtractTextPlugin.extract(&#123;</span><br><span class="line">        use: loaders,</span><br><span class="line">        fallback: &apos;vue-style-loader&apos;,</span><br><span class="line">        publicPath: &quot;../../&quot;    //添加这一行</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="echarts关系图实例数据"><a href="#echarts关系图实例数据" class="headerlink" title="echarts关系图实例数据"></a>echarts关系图实例数据</h1><p>查看官方实例的时候，觉得这个<a href="https://www.echartsjs.com/examples/editor.html?c=graph-circular-layout" target="_blank" rel="noopener">关系图</a>很酷，想查看其数据格式，直接扒下来的是一个.gexf文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(&apos;data/asset/data/les-miserables.gexf&apos;, function (xml) &#123;</span><br><span class="line">    var graph = echarts.dataTool.gexf.parse(xml);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在本地依次引入了jQuery、echarts，结果dataTool在这呢<br><a href="https://github.com/apache/incubator-echarts/blob/master/dist/extension/dataTool.min.js" target="_blank" rel="noopener">https://github.com/apache/incubator-echarts/blob/master/dist/extension/dataTool.min.js</a></p><p>其实也不用那么麻烦，照样可以拿到解析后的json数据。首先在原实例里添加 <strong>console.log(graph)</strong> 再运行。打开控制台里复制数据，右键打印出的数据，<em>store as global variable</em>，再在控制台里输入 <strong>copy(temp1)</strong> ，就可以在编辑器里粘贴了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近实践开发中遇到一些小的问题，踩了不少坑，记录下来方便之后避免重复踩坑。&lt;/p&gt;
&lt;h1 id=&quot;vue兼容IE&quot;&gt;&lt;a href=&quot;#vue兼容IE&quot; class=&quot;headerlink&quot; title=&quot;vue兼容IE&quot;&gt;&lt;/a&gt;vue兼容IE&lt;/h1&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="前端" scheme="https://herasu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue数据" scheme="https://herasu.github.io/tags/vue%E6%95%B0%E6%8D%AE/"/>
    
      <category term="vue-cli兼容" scheme="https://herasu.github.io/tags/vue-cli%E5%85%BC%E5%AE%B9/"/>
    
      <category term="vue打包" scheme="https://herasu.github.io/tags/vue%E6%89%93%E5%8C%85/"/>
    
      <category term="echarts" scheme="https://herasu.github.io/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>圣杯布局与双飞翼布局小结</title>
    <link href="https://herasu.github.io/2018/12/13/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%E5%B0%8F%E7%BB%93/"/>
    <id>https://herasu.github.io/2018/12/13/圣杯布局与双飞翼布局小结/</id>
    <published>2018-12-13T12:55:32.120Z</published>
    <updated>2018-12-13T12:54:48.368Z</updated>
    
    <content type="html"><![CDATA[<p>在学习CSS布局中，三栏布局中的圣杯布局和双飞翼布局应用很广泛，并不是说完成左右宽度固定中间宽度自适应这类布局的时候一定要用这两个布局的原理去实现，实现同一个布局的方法很多，我们应该根据需求去选择。</p><p>不论是圣杯布局还是双飞翼布局其HTML的DOM结构都是按照中间—左侧—右侧的顺序，相应地也是按这个顺序进行加载，也就是我们常说的“重要的内容先加载”。</p><h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><h2 id="STEP-1-CREATE-THE-FRAME"><a href="#STEP-1-CREATE-THE-FRAME" class="headerlink" title="STEP 1: CREATE THE FRAME"></a>STEP 1: CREATE THE FRAME</h2><p>先写好整体框架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>用希望左右列占据的宽度作为内边距填充容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">  padding-left: 200px;   /* 左列宽度 */</span><br><span class="line">  padding-right: 150px;  /* 右列宽度 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5dsakfdcj20f009q74c.jpg" alt></p><h2 id="STEP-2-ADD-THE-COLUMNS"><a href="#STEP-2-ADD-THE-COLUMNS" class="headerlink" title="STEP 2: ADD THE COLUMNS"></a>STEP 2: ADD THE COLUMNS</h2><p>加入具体的左中右三列，注意中间要放在前面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接着相应的CSS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#container .column &#123;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">#center &#123;</span><br><span class="line">  width: 100%;  /*指的是除了padding的container的div宽度*/</span><br><span class="line">&#125;</span><br><span class="line">#left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">#right &#123;</span><br><span class="line">  width: 150px; </span><br><span class="line">&#125;</span><br><span class="line">#footer &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于中间列宽度是100%，所以左列和右列被挤到下面了</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5dstgtsdj20f009q0st.jpg" alt></p><h2 id="STEP-3-PULL-THE-LEFT-COLUMN-INTO-PLACE"><a href="#STEP-3-PULL-THE-LEFT-COLUMN-INTO-PLACE" class="headerlink" title="STEP 3: PULL THE LEFT COLUMN INTO PLACE"></a>STEP 3: PULL THE LEFT COLUMN INTO PLACE</h2><p>现在需要将左右两列给弄到上面中间列左右空出来的padding的位置去</p><p>中间列已经在它该在的位置了，所以先不处理它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  margin-left: -100%;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5dugbt3ug20f009qt8l.gif" alt></p><p>这里用100%的负边距将左列移到中间列的最左侧，这100%表示的是container这个div的宽度，也相当于中间列的宽度。现在左列已经上去了，但没有去到该去的位置（padding-left:200px)，这时用到了定位position，right:200px这条CSS将左列往左推了200px,也就是它自己的宽度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#container .columns &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">#left &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">  right: 200px;        /* 自身宽度 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5dtbaicbj20f009qq2y.jpg" alt></p><h2 id="STEP-4-PULL-THE-RIGHT-COLUMN-INTO-PLACE"><a href="#STEP-4-PULL-THE-RIGHT-COLUMN-INTO-PLACE" class="headerlink" title="STEP 4: PULL THE RIGHT COLUMN INTO PLACE"></a>STEP 4: PULL THE RIGHT COLUMN INTO PLACE</h2><p>由于左侧列离开了原来的位置，右列就会自然而然的流过去占据以前左列的位置，那现在怎么把右侧移到它该去的位置呢？（预留的padding-right：150px）同样使用负边距</p><ul><li>方法一：与操作左列一样， margin-left: -100%后会到中间列的最左侧，此时利用定位将右列向右推倒最右边，设置为left:100%，这100%表示中间列的宽度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#right &#123;</span><br><span class="line">   width: 150px;</span><br><span class="line">   margin-left: -100%;</span><br><span class="line">   left:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：使用margin-right，设置为-150px,即右列的宽度；或者设置为-100%，这里100%还是指的container这个div的宽度，也就是中间列的宽度。事实上只要外边距的绝对值大于其自身的宽度即150px均能达到这个效果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#right &#123;</span><br><span class="line">  width: 150px;</span><br><span class="line">  margin-right: -150px;  /* 自身宽度 */</span><br><span class="line">  //margin-right: -100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此就将它们的位置放对了。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5dv37qujj20f009qmx5.jpg" alt></p><h2 id="STEP-5-DESIGN-DEFENSIVELY"><a href="#STEP-5-DESIGN-DEFENSIVELY" class="headerlink" title="STEP 5: DESIGN DEFENSIVELY"></a>STEP 5: DESIGN DEFENSIVELY</h2><p>如果浏览器窗口缩小，中间列宽度小于左列的话，这个布局在标准浏览器中会垮掉，因此有必要设定一个最小宽度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  min-width: 550px;  /* 2倍左列宽度+右列宽度 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STEP-6-EQUAL-HEIGHT-COLUMNS"><a href="#STEP-6-EQUAL-HEIGHT-COLUMNS" class="headerlink" title="STEP 6: EQUAL-HEIGHT COLUMNS"></a>STEP 6: EQUAL-HEIGHT COLUMNS</h2><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5dv7awkcj21gv0p677d.jpg" alt></p><p>此时很容易出现三列不等高的情况，这个问题容易解决，常用的方法是利用内边距比负外边距绝对值大一点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#container .column &#123;</span><br><span class="line">  padding-bottom: 20010px; </span><br><span class="line">  margin-bottom: -20000px;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为防止溢出，为外层div添加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">padding-left: 200px;    /* 左列宽度 */</span><br><span class="line">padding-right: 150px;  /* 右列宽度 */</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上当container内容区没有浏览器窗口大的时候页脚也会出现一部分空白，所以在这种情况下若需要页脚们可以讲内容区设置固定高度后再添加页脚</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5dz8ze6oj21h90qcjva.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#container .column &#123;</span><br><span class="line">height: 1200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h1><p>双飞翼这个布局来源于淘宝的页面布局，是源于对页面的形象表达。</p><h2 id="第一步-确定结构"><a href="#第一步-确定结构" class="headerlink" title="第一步 确定结构"></a>第一步 确定结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">　　&lt;div class=&quot;center&quot;&gt;中间&lt;/div&gt;</span><br><span class="line">　　&lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;</span><br><span class="line">　　&lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>现在的问题是在不改变DOM结构的情况下如何让center展示在中间呢</p><h2 id="第二步-基本CSS"><a href="#第二步-基本CSS" class="headerlink" title="第二步 基本CSS"></a>第二步 基本CSS</h2><p>这时CSS就要发挥其作用了，将container容器定义一个100%的宽度，对其中每个部分，中左右都设置为浮动，这跟圣杯布局中是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.container&#123; </span><br><span class="line">    width:100%;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123; </span><br><span class="line">    float:left; </span><br><span class="line">    width:100%; </span><br><span class="line">&#125;</span><br><span class="line">.left &#123; </span><br><span class="line">    float:left; </span><br><span class="line">    width:200px;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123; </span><br><span class="line">    float:left; </span><br><span class="line">    width:150px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时中间占据了整个宽度，左右两侧自然也被挤下去了。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5e8qq4ltj21h00igwer.jpg" alt></p><h2 id="第三步-确定各列正确位置"><a href="#第三步-确定各列正确位置" class="headerlink" title="第三步 确定各列正确位置"></a>第三步 确定各列正确位置</h2><p>左外边距为-100%，在浮动情况下，负外边距会导致div上移，而使用-100%可以确保它移动到最左侧。对右侧也设置该属性，值为-150px，注意负外边距一定等于该div的宽度才会刚好在最右侧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.left &#123; </span><br><span class="line">    margin-left:-100%; </span><br><span class="line">&#125;</span><br><span class="line">.right &#123; </span><br><span class="line">     margin-left:-150px;   /* 自身宽度 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5eawy4e3j21gx0a1t8q.jpg" alt></p><p>注意这里和圣杯布局的区别，圣杯布局是将右侧的属性设定为右外边距，原因在于在圣杯布局中，一开始我们将是希望左右列占据的宽度作为container这个div的内边距去填充的，而在双飞翼布局中，并没有给container设置padding属性，也就是说到目前为止container的内容区宽度（不包括padding、margin和border）占据了整个浏览器视口。细心的同学可能发现了，中间文本去哪了呢？接下来就解决这个问题</p><h2 id="第四步-让中间列正确显示"><a href="#第四步-让中间列正确显示" class="headerlink" title="第四步 让中间列正确显示"></a>第四步 让中间列正确显示</h2><p>经过上述的设置，中间列两侧的内容会被左右两列给挡住，为了解决这个问题，下面是淘宝的做法：</p><p>1、DOM结构的改变：在.center下再次添加一个class=”wrap”的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">　　&lt;div class=&quot;center&quot;&gt;</span><br><span class="line">　　    &lt;div class=&quot;wrap&quot;&gt;中间&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">　　&lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;</span><br><span class="line">　　&lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2、利用CSS调整wrap的位置，就是把左右被挡住的部分，设置为wrap这个div的左、右外边距即可，最终的CSS如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.container &#123; </span><br><span class="line">width:100%; </span><br><span class="line">&#125;</span><br><span class="line">.container .center &#123; </span><br><span class="line">float:left;</span><br><span class="line">width:100%; </span><br><span class="line">&#125;</span><br><span class="line">.container .center .wrap &#123;</span><br><span class="line">    margin-left:200px;    /*大于等于左侧宽度*/</span><br><span class="line">    margin-right:150px;   /*大于等于右侧宽度*/</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line"> float:left; </span><br><span class="line"> width:200px; </span><br><span class="line"> margin-left:-100%;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line"> float:left; </span><br><span class="line"> width:150px; </span><br><span class="line"> margin-left:-150px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fy5ejwjtlej21gx09mmx6.jpg" alt></p><p>到此已实现了基本功能，等高柱也可以按圣杯布局中同样的方法设定，至于样式上的调整此处不再赘述。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>事实上，圣杯布局其实和双飞翼布局是一回事。它们实现的都是三栏布局，两边的盒子宽度固定，中间盒子宽度自适应。它们实现的效果是一样的，差别在于其实现的过程与思想。实际应用中还应灵活使用，根据需要调整。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://alistapart.com/article/holygrail" target="_blank" rel="noopener">圣杯布局</a></p><p><a href="http://www.cnblogs.com/langzs/archive/2013/01/27/taobaoshuangfeiyi.html" target="_blank" rel="noopener">双飞翼布局</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习CSS布局中，三栏布局中的圣杯布局和双飞翼布局应用很广泛，并不是说完成左右宽度固定中间宽度自适应这类布局的时候一定要用这两个布局的原理去实现，实现同一个布局的方法很多，我们应该根据需求去选择。&lt;/p&gt;
&lt;p&gt;不论是圣杯布局还是双飞翼布局其HTML的DOM结构都是按照中
      
    
    </summary>
    
      <category term="前端" scheme="https://herasu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://herasu.github.io/tags/CSS/"/>
    
      <category term="layout" scheme="https://herasu.github.io/tags/layout/"/>
    
      <category term="三栏布局" scheme="https://herasu.github.io/tags/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>基于深度学习的在线恶意URL和DNS检测方案</title>
    <link href="https://herasu.github.io/2018/11/04/Malicious%20URL%20detection/"/>
    <id>https://herasu.github.io/2018/11/04/Malicious URL detection/</id>
    <published>2018-11-04T10:58:54.205Z</published>
    <updated>2018-11-04T11:01:34.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于深度学习的在线恶意URL和DNS检测方案"><a href="#基于深度学习的在线恶意URL和DNS检测方案" class="headerlink" title="基于深度学习的在线恶意URL和DNS检测方案"></a>基于深度学习的在线恶意URL和DNS检测方案</h1><p><strong>原文作者</strong>：Jianguo Jiang, Jiuming Chen, K-K-Raymond Choo, Chao Liu, Kunying Liu and Min Yu</p><p><strong>原文标题</strong>：A Deep Learning Based Online Malicious URL and DNS Detection Scheme</p><p><strong>原文会议</strong>：Security and Privacy in Communication Networks(SecureComm 2017)</p><p><strong>原文链接</strong>：<a href="https://link.springer.com/chapter/10.1007/978-3-319-78813-5_22" target="_blank" rel="noopener">https://link.springer.com/chapter/10.1007/978-3-319-78813-5_22</a></p><p>随着越来越多的设备联网，利用人、过程和技术漏洞的网络威胁越来越普遍。比如去年的勒索软件WannaCry造成了巨大的损失，最常见的方式就是引诱人们点击恶意网站，也就是钓鱼。一个钓鱼网站可能会伪装成各种各样的广告，以达到攻击的目的。为了应对这种网络安全威胁，检测恶意URL非常有必要。目前对URL和DNS进行研究和检测的相关文献其实已经很多了，各种技术也应用得很成熟，足见在恶意网络攻击中这两类攻击媒介之常见。</p><p>本文提出了一种基于字符级深度神经网络的在线检测方案。具体而言，该方案使用一些自然语言处理方法将URL和DNS字符串映射为矢量形式。再使用CNN（卷积神经网络）网络框架自动提取恶意特征并训练分类模型。使用真实的URL和DNS数据集进行实验，结果表明，所提出的方法优于几种最先进的基线方法，有较高的效率和可扩展性。</p><h2 id="作者的工作："><a href="#作者的工作：" class="headerlink" title="作者的工作："></a>作者的工作：</h2><p>论文从如今网络空间安全的严峻形势出发，引入恶意URL在攻击行为中的表现形式，主要是钓鱼网站。比较前人所做的工作并总结研究成果，提出基于深度学习的在线恶意URL和DNS检测方案，主要分为三个模块，数据集的收集、深度学习分类模型的构建和威胁情报的收集更新。论文还对构建的分类检测模型进行真实数据验证和基于各项指标评估。最后讨论了所提出的方法可通用于短文本检测问题以及将在实际环境中部署所提出的方法。</p><h2 id="一、引言与文献综述"><a href="#一、引言与文献综述" class="headerlink" title="一、引言与文献综述"></a>一、引言与文献综述</h2><p>针对传统的恶意检测URL的方法依赖于专家或机器学习提取的特征，作者提出三个明显的问题：</p><ul><li><p>(1) 网站数目及网络流量大幅增加，令有效及时检测恶意URL的工作变得复杂(例如，由于恶意URL需要大量新功能)。</p></li><li><p>(2) 不平衡数据集。与在线流量总量相比，恶意url的数量相对较少，这种不平衡(普通URL和恶意URL之间)可能导致不稳定的分类模型。</p></li><li><p>(3) 不断发展的攻击技术。攻击者通常使用广泛的技术来规避或避免现有的检测技术。</p></li></ul><p>基于此，作者提出了基于字符级的并将深度神经网络、自语言处理与威胁情报三者相结合的检测方案。</p><p>而现有的检测恶意URL的方法可分为以下几类：</p><table><thead><tr><th>方法</th></tr></thead><tbody><tr><td>基于黑名单</td><td></td></tr><tr><td>基于特征集</td><td></td></tr><tr><td>基于机器学习</td><td></td></tr><tr><td>基于URL</td><td></td></tr><tr><td>基于内容</td><td></td></tr></tbody></table><p>本文只关注与在线检测相关的方法：基于URL的方法。<br>其中基于URL的方法是只利用URL自身的结构如长度、域名和URL中点(.)的数量，即紧紧围绕URL自身的属性进行。该方法效率高因此也被广泛应用，无论是手工提取特征集还是利用机器学习检测。</p><p>下表展示了三种常用机器学习算法的特点与局限性</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fwbie64se8j20j107jq3z.jpg" alt></p><p>而本文使用深度学习算法CNN去自动提取URL中隐藏的特征信息，具有强泛化能力。</p><h2 id="二、提出方法"><a href="#二、提出方法" class="headerlink" title="二、提出方法"></a>二、提出方法</h2><p>整个模型的框架图：</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fwo0vlme37j20j30g7n1n.jpg" alt></p><p>总体来看就是训练集导入深度学习分类模型，模型采用CNN框架，数据预处理和嵌入使用了自然语言处理方法，在生成模型后将收集到的URL和DNS的威胁情报加入更新，最终得到在线恶意URL检测模型。</p><h3 id="1-训练数据集"><a href="#1-训练数据集" class="headerlink" title="1.训练数据集"></a>1.训练数据集</h3><h4 id="1-1数据特征"><a href="#1-1数据特征" class="headerlink" title="1.1数据特征"></a>1.1数据特征</h4><p>URL字符串包含了三种不同的语义段：域名、目录路径和文件名，还包含了数字、字母和”?””,”&amp;”等符号。对此如下形式的元祖用于定义一个URL字符串：p = (h, d, f)。h代表域名，d代表目录路径，f则代表了文件名。</p><p>假设有恶意URL字符串p =（h，d，f）和正常URL字符串p’=（h’，d’，f’），如果存在文本片段形式的t’或其他形式的t”，t’与t”的一个特征满足p的定义但不符合p’，那么t’与t”可作为对URL进行分类的特征。</p><p>恶意URL举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.aaa.com/1.php?Include=http://www.bbb.com/hehe.php</span><br><span class="line">http://www.sqlinsertion.com/adminlogin.php/**/and/**/1=1.</span><br></pre></td></tr></table></figure><h4 id="1-2模型评估"><a href="#1-2模型评估" class="headerlink" title="1.2模型评估"></a>1.2模型评估</h4><p>论文采用错误标记的URL数量和精确率评估准确性并采用运行时间评估效率。</p><p>数据集中malicious URL是negative sample负样本，normal URL是positive sample正样本。</p><p>Mislabeled number: FN + FP</p><p>Accuracy rate: TN/FN + TN.</p><h3 id="2-字符级深度学习框架"><a href="#2-字符级深度学习框架" class="headerlink" title="2.字符级深度学习框架"></a>2.字符级深度学习框架</h3><h4 id="2-1预处理"><a href="#2-1预处理" class="headerlink" title="2.1预处理"></a>2.1预处理</h4><p>由于HTTP和HTTPS协议的广泛使用，因此在检测中省略”http://“和”https://“是没有安全问题的。鉴于URL通常由数字，字母和一些符号组成。所以在文章提出的方法中，过滤了对分类结果影响很小的特殊符号，例如”_”和”#”等。经过预处理的数据集更简洁从而减少了之后步骤中的时间和资源需求。</p><h4 id="2-2嵌入"><a href="#2-2嵌入" class="headerlink" title="2.2嵌入"></a>2.2嵌入</h4><p>论文需要将URL序列向量化后作为深度学习框架的输入，字符转换为词向量使用的是自然语言处理中的独热编码方法。独热编码，又称一位有效码，用序列化的数字（只有0和1）表达特征。主要思路是使用N位数字对N种情况进行编码，例如一串长度为L的字符串，每位字符有M种情况，则经过向量化后为L*M的矩阵，其中超过L长度的字符将被舍去，不在字符表（覆盖了全部M种情况）上的以及空字符将使用0替代。字符表是一个包含了26个字母、10位数字和14个特俗符号的集合。</p><blockquote><p>abcdefghijklmnopqrstuvwxyz</p><p>0123456789</p><p>-;!?:@#$^*% = &lt;&gt;</p></blockquote><p>考虑到实际情况，实验中选择L=256,M=50。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fwo0w8bzj3j20jl0gojv7.jpg" alt></p><h4 id="2-3CNN框架与分类模型"><a href="#2-3CNN框架与分类模型" class="headerlink" title="2.3CNN框架与分类模型"></a>2.3CNN框架与分类模型</h4><p>这部分是将字符串嵌入矩阵后输入到深度学习框架的具体配置。CNN框架可自行了解，此处不再赘述。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fwo0xizlrjj20dk06aglz.jpg" alt></p><h3 id="3-更新"><a href="#3-更新" class="headerlink" title="3.更新"></a>3.更新</h3><p>由于深度学习模型的训练过程通常耗时较长，难以对在线检测系统进行更新。文章使用当前更新的威胁情报(如URL和DNS黑名单)和增量学习模型尽量减小影响。</p><h2 id="二、评估"><a href="#二、评估" class="headerlink" title="二、评估"></a>二、评估</h2><h3 id="1-实验环境与参照实验"><a href="#1-实验环境与参照实验" class="headerlink" title="1.实验环境与参照实验"></a>1.实验环境与参照实验</h3><p>论文选了两个参照实验：</p><ul><li>基于人工提取特征，特征包括了URL长度，“.”的数量和词语特征等，这些特征形成了一个非常大但稀疏的特征向量。</li><li>为了比较基于字符级嵌入的深度学习和基于字级嵌入的深度学习之间的准确性实现的基于字级嵌入的深度学习框架。</li></ul><h3 id="2-数据"><a href="#2-数据" class="headerlink" title="2.数据"></a>2.数据</h3><p>对于恶意url，从Phish Tank和Virus Total获取。正常URL主要是从一些公开数据集中下载，比如谷歌和DMOZ<br>。训练数据集和测试数据集按照9:1随机分配，随机选择90%的标记数据作为训练数据集，其余10%作为测试数据集。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fwo0y6b1ejj20cc05ht90.jpg" alt></p><h3 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h3><p>X轴表示三种模型，Y轴表示测试集中每1000个URL里被标记错误的数量</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fwo0yl9ymqj20jw0bhwew.jpg" alt></p><p>X轴表示三种模型，Y轴表示对两个测试集进行分类时间（单位秒），两个测试集分别包括了1000与2000个URL</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fwo0z3eyzzj20k109yt9o.jpg" alt></p><h2 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h2><p>检测恶意URL和DNS的能力将越来越重要，在我们的互联网连接社会，特别是在物联网部署。<br>本文基于URL和DNS的文本模式，提出了一种基于字符级CNN的恶意URL和DNS检测方法。<br>我们使用真实的数据集来评估我们的方法，这表明我们的方法是准确和高效的。<br>此外，该方案是一种针对短文本检测问题的通用检测方案，在其他场合也有应用。<br>未来的研究包括在现实环境中部署所建议的方法，以便在必要时进行进一步的评估和微调。</p><h2 id="五、讨论"><a href="#五、讨论" class="headerlink" title="五、讨论"></a>五、讨论</h2><p>文章主要提出了使用深度学习来检测恶意URL与DNS，作者表示也适用于短文本的检测，我认为在文献综述那块，对比了三个（贝叶斯，SVM和逻辑回归）常用的机器学习的方法，只是定性地阐述了其速度、准确率与局限等方面的表现，但是并没有实际做实验验证，不同的实验数据对同一个模型是有不同的实验结果的。不过对于选取的参照实验具有代表性，一个验证了手动提取和深度学习自动学习特征；一个对比了字符级与词级的词向量表示方法，算法没有对比这也是前面所说的文献综述部分只是提到为止。我以前有学习过用深度学习检测DGA，使用的是RNN中的LSTM，本文使用了CNN，并说LSTM表现不如CNN（耗时明显）。希望我之后可以在实践中验证。其次，不断将更新的数据加入到数据集也是值得学习的地方，因为黑客不断地更新技术，恶意样本集也在变化，为了适应这种网络攻击的变化，我们也应随之更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于深度学习的在线恶意URL和DNS检测方案&quot;&gt;&lt;a href=&quot;#基于深度学习的在线恶意URL和DNS检测方案&quot; class=&quot;headerlink&quot; title=&quot;基于深度学习的在线恶意URL和DNS检测方案&quot;&gt;&lt;/a&gt;基于深度学习的在线恶意URL和DNS检测
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://herasu.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SecureComm 2017" scheme="https://herasu.github.io/tags/SecureComm-2017/"/>
    
      <category term="web security" scheme="https://herasu.github.io/tags/web-security/"/>
    
      <category term="Malicious URL Detection" scheme="https://herasu.github.io/tags/Malicious-URL-Detection/"/>
    
      <category term="deep learning" scheme="https://herasu.github.io/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>qs.parse()、qs.stringify()、JSON.parse()、JSON.stringify()示例</title>
    <link href="https://herasu.github.io/2018/09/28/qs%20%E5%92%8C%20json%20%E5%8C%BA%E5%88%AB/"/>
    <id>https://herasu.github.io/2018/09/28/qs 和 json 区别/</id>
    <published>2018-09-28T13:10:06.652Z</published>
    <updated>2018-09-28T13:18:38.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文只是几个例子没有详细研究各个方法"><a href="#本文只是几个例子没有详细研究各个方法" class="headerlink" title="本文只是几个例子没有详细研究各个方法"></a>本文只是几个例子没有详细研究各个方法</h2><h4 id="在写前端的时候经常会遇到对数据格式进行处理的情况，其中qs-parse-、qs-stringify-、JSON-parse-、JSON-stringify-也是常用的几种方法，对以上使用方法进行总结记下来以便之后查看方便。"><a href="#在写前端的时候经常会遇到对数据格式进行处理的情况，其中qs-parse-、qs-stringify-、JSON-parse-、JSON-stringify-也是常用的几种方法，对以上使用方法进行总结记下来以便之后查看方便。" class="headerlink" title="在写前端的时候经常会遇到对数据格式进行处理的情况，其中qs.parse()、qs.stringify()、JSON.parse()、JSON.stringify()也是常用的几种方法，对以上使用方法进行总结记下来以便之后查看方便。"></a>在写前端的时候经常会遇到对数据格式进行处理的情况，其中qs.parse()、qs.stringify()、JSON.parse()、JSON.stringify()也是常用的几种方法，对以上使用方法进行总结记下来以便之后查看方便。</h4><h4 id="一、JSON-parse-用于从一个字符串中解析出json对象"><a href="#一、JSON-parse-用于从一个字符串中解析出json对象" class="headerlink" title="一、JSON.parse()用于从一个字符串中解析出json对象"></a>一、JSON.parse()用于从一个字符串中解析出json对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;[&#123;&quot;userId&quot;: &quot;1&quot;,&quot;id&quot;: &quot;1&quot;,&quot;title&quot;: &quot;delectus aut autem&quot;,&quot;completed&quot;: &quot;false&quot;&#125;,&#123;&quot;userId&quot;: &quot;1&quot;,&quot;id&quot;: &quot;2&quot;,&quot;title&quot;: &quot;quis ut nam facilis et officia qui&quot;,&quot;completed&quot;: &quot;false&quot;&#125;,&#123;&quot;userId&quot;: &quot;1&quot;,&quot;id&quot;: &quot;3&quot;,&quot;title&quot;: &quot;fugiat veniam minus&quot;,&quot;completed&quot;: &quot;false&quot;&#125;,&#123;&quot;userId&quot;: &quot;1&quot;,&quot;id&quot;: &quot;4&quot;,&quot;title&quot;: &quot;et porro tempora&quot;,&quot;completed&quot;: &quot;true&quot;&#125;]&apos;;</span><br><span class="line"></span><br><span class="line">let arr = JSON.parse(str); //str必须满足引号使用规范，即：双引号和单引号相互嵌套</span><br><span class="line"></span><br><span class="line">arr:[&#123;userId: &quot;1&quot;, id: &quot;1&quot;, title: &quot;delectus aut autem&quot;, completed: &quot;false&quot;&#125;,</span><br><span class="line">    &#123;userId: &quot;1&quot;, id: &quot;2&quot;, title: &quot;quis ut nam facilis et officia qui&quot;, completed: &quot;false&quot;&#125;,</span><br><span class="line">    &#123;userId: &quot;1&quot;, id: &quot;3&quot;, title: &quot;fugiat veniam minus&quot;, completed: &quot;false&quot;&#125;,</span><br><span class="line">    &#123;userId: &quot;1&quot;, id: &quot;4&quot;, title: &quot;et porro tempora&quot;, completed: &quot;true&quot;&#125;];</span><br></pre></td></tr></table></figure><h4 id="二、JSON-stringify-用于从一个json对象解析出字符串"><a href="#二、JSON-stringify-用于从一个json对象解析出字符串" class="headerlink" title="二、JSON.stringify()用于从一个json对象解析出字符串"></a>二、JSON.stringify()用于从一个json对象解析出字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#123;userId: &quot;1&quot;, id: &quot;1&quot;, title: &quot;delectus aut autem&quot;, completed: &quot;false&quot;&#125;,</span><br><span class="line">    &#123;userId: &quot;1&quot;, id: &quot;2&quot;, title: &quot;quis ut nam facilis et officia qui&quot;, completed: &quot;false&quot;&#125;,</span><br><span class="line">    &#123;userId: &quot;1&quot;, id: &quot;3&quot;, title: &quot;fugiat veniam minus&quot;, completed: &quot;false&quot;&#125;,</span><br><span class="line">    &#123;userId: &quot;1&quot;, id: &quot;4&quot;, title: &quot;et porro tempora&quot;, completed: &quot;true&quot;&#125;];</span><br><span class="line"></span><br><span class="line">let str = JSON.stringify(arr);//全是双引号</span><br><span class="line"></span><br><span class="line">str:&apos;[&#123;&quot;userId&quot;:&quot;1&quot;,&quot;id&quot;:&quot;1&quot;,&quot;title&quot;:&quot;delectus aut autem&quot;,&quot;completed&quot;:&quot;false&quot;&#125;,&#123;&quot;userId&quot;:&quot;1&quot;,&quot;id&quot;:&quot;2&quot;,&quot;title&quot;:&quot;quis ut nam facilis et officia qui&quot;,&quot;completed&quot;:&quot;false&quot;&#125;,&#123;&quot;userId&quot;:&quot;1&quot;,&quot;id&quot;:&quot;3&quot;,&quot;title&quot;:&quot;fugiat veniam minus&quot;,&quot;completed&quot;:&quot;false&quot;&#125;,&#123;&quot;userId&quot;:&quot;1&quot;,&quot;id&quot;:&quot;4&quot;,&quot;title&quot;:&quot;et porro tempora&quot;,&quot;completed&quot;:&quot;true&quot;&#125;]&apos;;</span><br></pre></td></tr></table></figure><h4 id="三、qs-parse-将URL解析成对象的形式"><a href="#三、qs-parse-将URL解析成对象的形式" class="headerlink" title="三、qs.parse()将URL解析成对象的形式"></a>三、qs.parse()将URL解析成对象的形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let url = &apos;method=query_sql_dataset_data&amp;projectId=85&amp;appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let obj = qs.parse(url);//</span><br><span class="line">obj:&#123;</span><br><span class="line">      method: &quot;query_sql_dataset_data&quot;, </span><br><span class="line">      projectId: &quot;85&quot;, </span><br><span class="line">      appToken: &quot;7d22e38e-5717-11e7-907b-a6006ad3dba0&quot;&#125;;</span><br></pre></td></tr></table></figure><h4 id="四、qs-stringify-将对象解析成URL的形式"><a href="#四、qs-stringify-将对象解析成URL的形式" class="headerlink" title="四、qs.stringify()将对象解析成URL的形式"></a>四、qs.stringify()将对象解析成URL的形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">            type: &quot;POST&quot;,</span><br><span class="line">            dataType: &quot;json&quot;,</span><br><span class="line">            url: &quot;/users/login&quot;&#125;;</span><br><span class="line"></span><br><span class="line">let url = qs.stringify( obj)</span><br><span class="line"></span><br><span class="line">url:type=POST&amp;dataType=json&amp;url=%2Fusers%2Flogin</span><br></pre></td></tr></table></figure><p>qs.stringify(opts.data)<br>要注意在使用post请求时如果不使用qs.stringify()后台是拿不到数据的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本文只是几个例子没有详细研究各个方法&quot;&gt;&lt;a href=&quot;#本文只是几个例子没有详细研究各个方法&quot; class=&quot;headerlink&quot; title=&quot;本文只是几个例子没有详细研究各个方法&quot;&gt;&lt;/a&gt;本文只是几个例子没有详细研究各个方法&lt;/h2&gt;&lt;h4 id=&quot;在
      
    
    </summary>
    
      <category term="前端" scheme="https://herasu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="summary" scheme="https://herasu.github.io/tags/summary/"/>
    
      <category term="JS" scheme="https://herasu.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS伪元素整理小结</title>
    <link href="https://herasu.github.io/2018/08/01/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://herasu.github.io/2018/08/01/CSS伪元素总结/</id>
    <published>2018-08-01T08:59:19.260Z</published>
    <updated>2018-08-01T08:59:01.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS伪元素整理小结"><a href="#CSS伪元素整理小结" class="headerlink" title="CSS伪元素整理小结"></a>CSS伪元素整理小结</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CSS中有一个特性允许我们添加额外元素而不影响文档本身，即实际上文档中没有生成这些元素，但在表面上可见，这就是伪元素。伪元素是对元素中的特定内容进行操作。实际上，设计伪元素的目的就是选取某些内容第一个字母（一行）、前面（后面）或是占位符等普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以称作伪元素。伪元素在CSS1中就已经存在，CSS2和3中也有所增加，目前[CSS-PSEUDO-4] (Level 4)中也有部分处于试验阶段，表格中已用“*”标记。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>起初伪元素的语法是使用一个冒号“:”，但是随着web的发展，在CSS3中伪元素使用两个冒号“::”，以便将它与伪类区分开（如:hover，:active等）。然而，使用一个冒号还是两个冒号，浏览器都能识别它们。但是IE8只支持一个冒号的格式，建议使用两个冒号::与伪类区分。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>基本用法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector::pseudo-element &#123;property:value;&#125;</span><br></pre></td></tr></table></figure><ul><li>结合CSS类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector.class::pseudo-element &#123;property:value;&#125;</span><br></pre></td></tr></table></figure><ul><li>结合CSS伪类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector.class:pseudo-class::pseudo-element &#123;property:value;&#125;</span><br></pre></td></tr></table></figure><ul><li>结合多个伪元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selector::pseudo-element-1 </span><br><span class="line">selector::pseudo-element-2</span><br></pre></td></tr></table></figure><ul><li>多重伪元素与伪元素嵌套目前正逐步进行。</li></ul><h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><table><thead><tr><th>伪元素</th><th>功能</th><th>分类</th></tr></thead><tbody><tr><td>::first-letter</td><td>向文本的第一个字母添加特殊样式</td><td>Typographic</td></tr><tr><td>::first-line</td><td>向文本的首行添加特殊样式</td><td>Typographic</td></tr><tr><td>::before</td><td>在元素之前添加内容</td><td>Tree-Abiding</td></tr><tr><td>::after</td><td>在元素之后添加内容</td><td>Tree-Abiding</td></tr><tr><td>::placeholder*</td><td>选择一个表单元素的占位文本，它允许开发者和设计师自定义占位文本的样式。</td><td>Tree-Abiding</td></tr><tr><td>::marker*</td><td>选择列表的前置标记，一般包含着重符号或数字，任何设置 display: list-item属性的元素或伪元素都能适用</td><td>Tree-Abiding</td></tr><tr><td>::selection（::inactive-selection）</td><td>设置对象被选择时的样式， 应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）</td><td>Highlight</td></tr><tr><td>::grammar-error*</td><td>应用于浏览器标识为语法错误的文本段</td><td>Highlight</td></tr><tr><td>::spelling-erro*</td><td>表示浏览器标记为不正确拼写的文本段</td><td>Highlight</td></tr><tr><td>::cue</td><td>匹配所选元素中的WebVTT提示，可用于在VTT轨道的媒体中使用字幕和其他线索</td><td>\</td></tr><tr><td>::backdrop</td><td>在任何处于全屏模式的元素下的即刻渲染的盒子</td><td>\</td></tr></tbody></table><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>尽管有这么多个伪元素（相比伪类已经不多了），但是常用的是前四个，并且后面部分浏览器支持度很差。最最常用的是 “::before” 和 “::after”。</p><p>“::first-line” 与 “::first-letter”只能用于块级元素。</p><p>当宿主元素没有内容时”::before” 与 “::after”仍会正常工作，为inline内联元素，可通过display：block设置为block块元素。</p><p>content属性是伪元素必需的，若伪元素没有内容，需赋值为空格content:’’。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>CSS 伪元素用于将特殊的效果添加到某些选择器。伪元素十分好用，可以在不影响实际HTML结构的情况下使用，将会为设计某些样式省下不少时间。</p><p>参考：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference" target="_blank" rel="noopener">CSS reference</a></p><p><a href="http://www.w3school.com.cn/css/css_pseudo_elements.asp" target="_blank" rel="noopener">W3school</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS伪元素整理小结&quot;&gt;&lt;a href=&quot;#CSS伪元素整理小结&quot; class=&quot;headerlink&quot; title=&quot;CSS伪元素整理小结&quot;&gt;&lt;/a&gt;CSS伪元素整理小结&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="前端" scheme="https://herasu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://herasu.github.io/tags/CSS/"/>
    
      <category term="pseudo-element" scheme="https://herasu.github.io/tags/pseudo-element/"/>
    
      <category term="summary" scheme="https://herasu.github.io/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu误删(锁)管理员账户/忘记密码的解决方法</title>
    <link href="https://herasu.github.io/2018/07/30/ubuntu14.04%E8%AF%AF%E5%88%A0%E7%AE%A1%E7%90%86%E5%91%98%E8%B4%A6%E6%88%B7or%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://herasu.github.io/2018/07/30/ubuntu14.04误删管理员账户or忘记密码的解决方法/</id>
    <published>2018-07-30T13:24:00.621Z</published>
    <updated>2018-07-30T13:23:50.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu14-6-04误删-锁-管理员账户-忘记密码的解决方法"><a href="#ubuntu14-6-04误删-锁-管理员账户-忘记密码的解决方法" class="headerlink" title="ubuntu14/6.04误删(锁)管理员账户/忘记密码的解决方法"></a>ubuntu14/6.04误删(锁)管理员账户/忘记密码的解决方法</h1><p><strong>原文链接</strong>：<a href="https://wenku.baidu.com/view/4a80f931b52acfc789ebc97c" target="_blank" rel="noopener">https://wenku.baidu.com/view/4a80f931b52acfc789ebc97c</a></p><p>几个月前没事手贱误把管理员账户给锁了，由于里面有重要的文件，就查找网上的办法，试了很多方法也没法进去，密码是记得的，但是密码无效……试了很多方法无效，最终下面的方法成功解决，转发以做个记录，万一以后又遇到了呢????原文是13.04，几个月前我用的14.04，事实证明16.04也适用。</p><p>首先介绍下我是如何作死的，看官方文档的时候觉得有意思就想试试，毕竟下面有解锁，然而一锁上就没法解了</p><p><img src="http://ww1.sinaimg.cn/mw690/720b6cbaly1fts5jqym1vj208p04n0sn.jpg" alt></p><p>等到再次开机时，输入密码已经没用了，无效，密码肯定是没错，毕竟密码就123456你说我还能记错吗，可以看到输入框后面有个警示符</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1fts6yrjiljj20dv0afq59.jpg" alt></p><p>好了，接下来就是解锁过程了！</p><p>开机，长按shift进入（虚拟机按esc），选择第二个选项，进入高级选项<strong>(Advanced)</strong>：</p><p> <img src="http://ww1.sinaimg.cn/large/720b6cbaly1fts6cv05bjj20hr0bm748.jpg" alt></p><p>再进入恢复模式<strong>(recovery mode)</strong>，接着把光标移动到<strong>root</strong>上，回车</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1fts6er9zf2j20ii09ujre.jpg" alt></p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd uesrname    //username替换为你的用户名</span><br></pre></td></tr></table></figure><p>提示错误信息：<br><em>Authentication token manipulation error</em></p><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1fts6raqpssj20cy0360sk.jpg" alt></p><ol><li>分区没有空间导致，<br>解决办法是用df查看根分区，如果满的话，删除不要的文件。</li><li>/etc/passwd 和/etc/shadow不同步。</li></ol><ul><li>解决办法直接输入命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwconv</span><br></pre></td></tr></table></figure></li></ul><p>回车，结果出现错误提示信息：<em>pwconv cannot lock /etc/passwd;try again later</em></p><p>意思是passwd被锁定了，稍后再试。</p><ul><li>出现以上信息后，得想办法啊。稍后再试，我稍后试了好几回，都没成功。看来得另外想办法。来命令，给passwd文件加权限：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chomd 777 /etc/passwd</span><br></pre></td></tr></table></figure><p>结果又出提示错误信息：<br><em>chmod：changing permissions of ‘/etc/passwd’; Read-only file system</em></p><ul><li>又找新的方法，解决这个问题，分别输入以下两行命令后</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 666 /dev/null</span><br><span class="line">mount -o remount,rw /</span><br></pre></td></tr></table></figure><p>再输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /etc/passwd</span><br></pre></td></tr></table></figure></p><p>这下没提示错误了。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1fts73bocnej20b2028t8i.jpg" alt></p><p>接下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /etc/passwd      //查看文件权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwconv       //同步/etc/passwd和/etc/shadow两个文件</span><br></pre></td></tr></table></figure><p>这下成功了，没提示错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username     //重新设置你的用户名username的密码</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1fts6qsqqlvj20em03zglh.jpg" alt></p><p>再接着输入两次相同的密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot     //重新启动系统。</span><br></pre></td></tr></table></figure><p>原文还有一种方法没有试过，网上给的大多数方法只到第一步输入用户名和新密码后就显示修改成功，然而我跟这位遇到的情况一样很多错误提示，为此记录下来备用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu14-6-04误删-锁-管理员账户-忘记密码的解决方法&quot;&gt;&lt;a href=&quot;#ubuntu14-6-04误删-锁-管理员账户-忘记密码的解决方法&quot; class=&quot;headerlink&quot; title=&quot;ubuntu14/6.04误删(锁)管理员账户/忘记
      
    
    </summary>
    
      <category term="教程" scheme="https://herasu.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="tips" scheme="https://herasu.github.io/tags/tips/"/>
    
      <category term="linux ubuntu" scheme="https://herasu.github.io/tags/linux-ubuntu/"/>
    
      <category term="repost" scheme="https://herasu.github.io/tags/repost/"/>
    
  </entry>
  
  <entry>
    <title>间谍浏览器扩展程序的分析和检测</title>
    <link href="https://herasu.github.io/2018/07/30/spying%20extension/"/>
    <id>https://herasu.github.io/2018/07/30/spying extension/</id>
    <published>2018-07-30T07:53:13.208Z</published>
    <updated>2018-07-30T07:52:51.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我用我的小眼睛窥探：间谍浏览器扩展程序的分析和检测"><a href="#我用我的小眼睛窥探：间谍浏览器扩展程序的分析和检测" class="headerlink" title="我用我的小眼睛窥探：间谍浏览器扩展程序的分析和检测"></a>我用我的小眼睛窥探：间谍浏览器扩展程序的分析和检测</h1><p><strong>原文作者</strong>：Anupama Aggarwal, Saravana Kumar, Bimal Viswanath, Liang Zhang, Ayush Shah, Ponnurangam Kumaraguru</p><p><strong>原文标题</strong>：Spy with My Little Eye: Analysis and Detection of Spying Browser Extensions.</p><p><strong>原文会议</strong>：IEEE European Symposium on Security and Privacy 2018 (EuroS&amp;P)</p><p><strong>原文链接</strong>：<a href="http://precog.iiitd.edu.in/pubs/spying-extensions-eurosandp.pdf" target="_blank" rel="noopener">http://precog.iiitd.edu.in/pubs/spying-extensions-eurosandp.pdf</a></p><p>用户隐私信息泄露已成为如今网络安全的一大威胁，而每天都在使用的浏览器也会将我们的信息泄露，本文讨论的是如何检测浏览器中的扩展程序对用户的隐私进行获取、泄露这一重要的研究问题。以谷歌浏览器Chrome为研究对象（也适用于其他浏览器如Firefox），尽管官方也对这些扩展程序采取了一些措施以识别其中的恶意扩展程序，但谷歌网上应用商店中spying extension一直都存在。<br>本文提出使用深度学习来进行漏洞检测，免去繁重且复杂的人工特征工程任务。作者首先对其多种特征进行分析，根据表现能力确定合适的特征（API Calls)，再与多种检测方法进行对比，最终作者提出了基于深度学习检测spying extension的方法，并进行评估与验证，经过测试，其检测模型的精确率为90.02%，召回率为93.31%。作者进一步将该模型应用到余下的Chrome扩展程序中并检测到了新的65个spying extension。</p><h2 id="作者的工作："><a href="#作者的工作：" class="headerlink" title="作者的工作："></a>作者的工作：</h2><p>首先引入浏览器泄露用户隐私话题，对spying extension定义,收集spying类的原始数据（收集到的扩展程序共为43521个，其中218个为spying extension）。论文从用户个人信息被盗取，Spying的五类行为以及其流行度（用户量、评分和评论等）和信誉（问题与建议）和开发者与正常程序作比较，发现其一些规律，确定着手点为从spying extension的动态行为去检测。训练与验证，总结前人的研究成果，包括特征工程（静态/动态），机器学习分类器（逻辑回归模型、决策树、随机森林、Adaboost、支持向量机、神经网络）检测结果。设计深度学习检测模型实现自动检测。最后讨论了边界部署和移动端的检测可行性。</p><h2 id="一、数据收集"><a href="#一、数据收集" class="headerlink" title="一、数据收集"></a>一、数据收集</h2><h3 id="1-spying-extension"><a href="#1-spying-extension" class="headerlink" title="1.spying extension"></a>1.spying extension</h3><p>作者给出的定义是，其行为中有获取用户信息（浏览记录、cookie、社交媒体口令和地理位置等），存储用户的这些隐私，再发送到远程的主机。满足以上行为且在其功能声明中没有提及或对其功能没有必要的就是spying extension。</p><h3 id="2-数据收集过程"><a href="#2-数据收集过程" class="headerlink" title="2.数据收集过程"></a>2.数据收集过程</h3><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1ftrwj5ksm1j20qi0cojud.jpg" alt></p><p>由于spying extension数据较少，采用1:5的比例进行训练（207:1035）,五折交叉检验充分利用数据。<br><img src="http://ww1.sinaimg.cn/large/720b6cbaly1ftrwldaqv9j20r90apgo9.jpg" alt></p><h2 id="二、分析spying-extension"><a href="#二、分析spying-extension" class="headerlink" title="二、分析spying extension"></a>二、分析spying extension</h2><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1ftrwlskslij20tc0l3t9b.jpg" alt><br><img src="http://ww1.sinaimg.cn/large/720b6cbaly1ftrwkd90iij20s909w76g.jpg" alt></p><p>以上三大类特征/行为作为检测点都不够靠谱，进一步地，作者对spying extension的行为从时间线进行分析，发现一定规律。且实验表明使用API Calls作为特征检测结果是最好的。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbaly1ftrwz2tm1dj20mn08jaax.jpg" alt></p><h2 id="三、自动检测模型设计"><a href="#三、自动检测模型设计" class="headerlink" title="三、自动检测模型设计"></a>三、自动检测模型设计</h2><h3 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h3><h4 id="1-选择特征"><a href="#1-选择特征" class="headerlink" title="1.选择特征"></a>1.选择特征</h4><table><thead><tr><th>静态</th><th>动态</th></tr></thead><tbody><tr><td>permission</td><td>Chrome API Calls</td></tr><tr><td>javascript based</td><td>client side storage</td></tr><tr><td>others</td><td>network log</td></tr></tbody></table><p>利用API Call序列的好处</p><ul><li>不用手工，深度学习</li><li>主要特征，且有效，比起其他特征不易被开发者绕过</li><li>能适应动态的行为，比如周期性的切换状态的扩展程序</li><li>包括了大多数其他动态特征</li></ul><h4 id="2-选择神经网络"><a href="#2-选择神经网络" class="headerlink" title="2. 选择神经网络"></a>2. 选择神经网络</h4><p>循环神经网络在和处理自然语言和时序数据领域非常成功，作者在前文确定使用API call names序列作为判断的依据，需要依赖上下文环境。由于RNN自身的局限性（不适用于长期的依赖，作者选择了RNN的变种LSTM来进行检测。具体超参数与结构的设置原文有详细介绍。评估指标：召回率、精确率和两者的曲线。从FP、FN、鲁棒性和包括Web API调用的结果（更好）分析学习结果。</p><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p>在实际环境测试，从余下42110中检测出90个，其中65个确定为spying extension，剩下25个中，20个是正常的（被标记为spying因为有一些spying的行为但是又是功能必须的），另外5个不确定。</p><h2 id="四、边界部署与相关研究"><a href="#四、边界部署与相关研究" class="headerlink" title="四、边界部署与相关研究"></a>四、边界部署与相关研究</h2><h3 id="1-边界部署"><a href="#1-边界部署" class="headerlink" title="1.边界部署"></a>1.边界部署</h3><p>将检测模型作为一个扩展程序部署到浏览器，用于分析别的扩展程序调用API。</p><p>三点好处：</p><ul><li>基于用户生成的工作量启用检测。</li><li>告知用户隐私泄露风险。</li><li>早期检测，对于逃避集中检测的spying extension起到二次检测的保障。</li></ul><p>作者还提到可以将轻量级的机器学习客户端检测用于移动端，并认为随着深度学习的优化，客户端的防御是很有价值的。</p><h3 id="2-相关研究"><a href="#2-相关研究" class="headerlink" title="2.相关研究"></a>2.相关研究</h3><ul><li>用户行为追踪，列举了两个人的研究并作比较，鲁棒性较差。</li><li>检测范围更广的恶意扩展程序，列举了四个人的研究方法和成果，再一次表达自己的方法有多棒。</li><li>信息流控制，已有大量研究涉及IFC技术，以检测基于JavaScript的应用程序中的安全漏洞和隐私泄漏。但作者表示其面临着一些实际挑战，还是用文章提出的深度学习方法更好。</li></ul><h2 id="五、讨论"><a href="#五、讨论" class="headerlink" title="五、讨论"></a>五、讨论</h2><p>文章主要提出了使用深度学习来检测谷歌浏览器的spying扩展程序，对spying extension进行多方面的分析，与多种方法比较。数据表明作者所使用的深度学习RNN表现更好。但在数据收集过程，第一步利用一种启发式（heuristics）方法缩减候选名单，是否可靠。其次三个步骤中重复2、3，依赖专家主观经验确定的数据收集方式有局限。数据集的优劣直接关系了漏报率和误报率，怎么样选好数据集是非常重要的一步，这是一个难点。文章对spying extension的筛选主要通过一定程度自动筛选后的再进行手工提取，并且文章的spying种类、数量都不多，这也是最后在实际环境中测试后作者表明可以通过增加新的训练集以提高模型的有效性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我用我的小眼睛窥探：间谍浏览器扩展程序的分析和检测&quot;&gt;&lt;a href=&quot;#我用我的小眼睛窥探：间谍浏览器扩展程序的分析和检测&quot; class=&quot;headerlink&quot; title=&quot;我用我的小眼睛窥探：间谍浏览器扩展程序的分析和检测&quot;&gt;&lt;/a&gt;我用我的小眼睛窥探：间
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://herasu.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="web security" scheme="https://herasu.github.io/tags/web-security/"/>
    
      <category term="deep learning" scheme="https://herasu.github.io/tags/deep-learning/"/>
    
      <category term="EuroS&amp;P 2018" scheme="https://herasu.github.io/tags/EuroS-P-2018/"/>
    
      <category term="Chrome Extenison" scheme="https://herasu.github.io/tags/Chrome-Extenison/"/>
    
  </entry>
  
  <entry>
    <title>CSS-doodle体验</title>
    <link href="https://herasu.github.io/2018/07/23/CSS%20doodle%E4%BD%93%E9%AA%8C/"/>
    <id>https://herasu.github.io/2018/07/23/CSS doodle体验/</id>
    <published>2018-07-23T13:38:38.010Z</published>
    <updated>2018-07-23T13:33:40.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现一个有趣的用CSS绘制Web图片的组件。官网将其描述为：</p><blockquote><p>A web component for drawing patterns with CSS.</p></blockquote><p><strong>[注意]</strong>：该组件目前只能在最新的Chrome和Safari浏览器上正常运行。如果想在其他浏览器上使用，则需要相关的polyfills。</p><h2 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h2><p>还是三种熟悉的使用方式:</p><ol><li>cdn</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/css-doodle/0.4.2/css-doodle.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2.将其下载到本地引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;path/to/ss-doodle-0.4.2.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>3.通过npm的方式安装再引入项目中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install css-doodle</span><br><span class="line">import CSSDoodle from &apos;css-doodle&apos;</span><br></pre></td></tr></table></figure></p><h2 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h2><p>主要是基于++Shadow DOM V1++和++Custom Elements V1++来构建的。语法是基于CSS的，提供了一些的实用函数和简写的属性。</p><h3 id="常用的一些选择器、属性和函数："><a href="#常用的一些选择器、属性和函数：" class="headerlink" title="常用的一些选择器、属性和函数："></a>常用的一些选择器、属性和函数：</h3><ul><li>:doodle：是一个特殊的选择器，其指向的是组件元素本身，即<css-doodle>。</css-doodle></li><li>:container：是容纳所有单元格的容器元素。它使用网格布局进行样式设置。</li><li>@even：对应的偶数单元格</li><li>@odd：类似于@even，对应的是奇数单元格</li><li>@grid：创建一个网格，其后面配置的参数说明你要创建的网格</li><li>@place-cell：将单元格相对布局</li><li>@size：设置单元格的width和height</li><li>@use：从自定义属性导入样式，允许从普通的css文件中编写样式</li><li>@shape：返回使用clip-path和polygon（）生成的css形状</li><li>@index()：是一个函数，返回当前单元格的索引号，注意其开始值是从1开始</li><li>@rand：从数字的范围内返回一个随机值</li><li>@pick：给定的列表中随机选取一个值</li><li>@calc(expr)、@abs()支持数学函数，以@为前缀</li><li>:after：每个单元格的伪元素，用于生成内容，比如demo中看到的字母和一些unicode编码的符号<br>JavaScript API还可以实现现有交互效果的图案<br>demo中使用了.update()函数，当你在屏幕单击时，整个组件会使用给定的样式重新刷新。<br>目前提供的API有grid、use和update</li></ul><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/HTML</span><br><span class="line">&lt;css-doodle class=&quot;doodle&quot;&gt;</span><br><span class="line"> :doodle &#123; </span><br><span class="line">    @grid: 20/ 100vmax; </span><br><span class="line">    background: #121525; </span><br><span class="line">  &#125; </span><br><span class="line">  :after &#123; </span><br><span class="line">    font-family: devicons; </span><br><span class="line">    content: &apos;\@hex(@rand(0x1234,0x5678))&apos;;</span><br><span class="line">    font-size: 3vmax; </span><br><span class="line">    color: hsla( @rand(360), 70%, 70%,@rand(.9) ); </span><br><span class="line">  &#125;</span><br><span class="line">   @keyframes turn &#123; </span><br><span class="line">    0% &#123; transform: rotate(0deg); &#125; </span><br><span class="line">    100% &#123; transform: rotate(360deg); &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  :hover &#123; </span><br><span class="line">    animation: turn 1s ease-in-out infinite; &#125; </span><br><span class="line">&lt;/css-doodle&gt;</span><br></pre></td></tr></table></figure><p>除了选择器和几个函数外，都是CSS中的语法，很好理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@grid: 20/ 100vmax;</span><br></pre></td></tr></table></figure><p>表示创建一个横竖均为20格，以可视范围的宽度或高度中较大的那个尺寸为网格的边长。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color: hsla( @rand(360), 70%, 70%,@rand(.9) );</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 这次还接触到了使用hsl和hsla表示颜色的方法<blockquote><p>H：<br>Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360<br><br>S：<br>Saturation(饱和度)。取值为：0.0% - 100.0%<br><br>L：<br>Lightness(亮度)。取值为：0.0% - 100.0%<br><br>A：<br>Alpha透明度。取值0~1之间。</p></blockquote></li></ul><ul><li style="list-style: none"><input type="checkbox" checked> 以及CSS3中添加动画的方式<br>在@keyframes中创建动画，记得把它捆绑到某个选择器，否则不会产生动画效果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: turn 1s ease-in-out infinite;</span><br></pre></td></tr></table></figure><p>至少规定以下两项 CSS3 动画属性</p><ol><li>规定动画的名称</li><li>规定动画的时长</li></ol><ul><li style="list-style: none"><input type="checkbox" checked> 添加点击事件：<br>利用JS API中.update()更新组件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/JS</span><br><span class="line">const Doodle = document.querySelector(&apos;.doodle&apos;);</span><br><span class="line">Doodle.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">  Doodle.update();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/ladyfish/" target="_blank" rel="noopener">Demo</a></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>在使用上目前所支持的浏览器较少，该组件运行的原理是使用CSS Grid和纯CSS规则制作的一些图案。除了CSS自带的规则之外，该组件还封装了一些函数和属性，能让你快速制作一些图案，还可以使用Unicode字符创建一些字符图案，也可以直接使用SVG作为背景图像。</p><p>参考：</p><p><a href="https://css-doodle.com/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://www.w3school.com.cn/css3/css3_animation.asp" target="_blank" rel="noopener">CSS3动画</a></p><p><a href="https://surmon.me/article/58" target="_blank" rel="noopener">CSS中的尺寸单位</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近发现一个有趣的用CSS绘制Web图片的组件。官网将其描述为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A web component for drawing patterns with CSS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;[注意]&lt;/st
      
    
    </summary>
    
      <category term="前端" scheme="https://herasu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://herasu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>vue在线翻译练习</title>
    <link href="https://herasu.github.io/2018/07/23/vue%E5%9C%A8%E7%BA%BF%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/"/>
    <id>https://herasu.github.io/2018/07/23/vue在线翻译练习/</id>
    <published>2018-07-23T13:38:36.964Z</published>
    <updated>2018-07-23T13:37:10.043Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始接触Vue，想通过一些实例对其使用更加熟悉。</p><h1 id="一、搭建过程与环境"><a href="#一、搭建过程与环境" class="headerlink" title="一、搭建过程与环境"></a>一、搭建过程与环境</h1><p>网上已经有很多教程可以参考，这里简单说一下流程。</p><ol><li>安装node.js，官网下载，直接下载node.js最新版本，避免版本过低影响使用</li><li>安装vue-cli</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install vue-cli -g</span><br></pre></td></tr></table></figure><p>以上每一步步骤完成之后，使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$xxx -v</span><br></pre></td></tr></table></figure></p><p>验证是否安装成功，但<strong>vue -V</strong>这里V需要大写。</p><p>如下图，出现相应的版本号，则说明安装成功。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsr8gn504fj20e304wglo.jpg" alt="image"></p><blockquote><p>vue-cli脚手架的优势：</p><ul><li>有一套成熟的vue项目架构设计,能够快速初始化一个Vue项目。</li><li>vue-cli是官方支持的一个脚手架，会随本版本进行迭代更新。</li><li>vue-cli提供了一套本地的node测试服务器，使用vue-cli自己提供的命令，就可以启动服务器。</li><li>有一套vue结构配置，它可以帮助我们写好vue.js代码快速构建项目的工具。</li><li>集成打包上线方案。</li></ul></blockquote><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsrty5cunrj211m0i8q5h.jpg" alt></p><h1 id="二、创建项目"><a href="#二、创建项目" class="headerlink" title="二、创建项目"></a>二、创建项目</h1><p>官方文档参考：<a href="https://note.youdao.com/" target="_blank" rel="noopener">https://vuejs-templates.github.io/webpack/</a></p><p>1.创建一个基于webpack模板的新项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vue init webpack my-project</span><br></pre></td></tr></table></figure></p><p>my-project是项目的名称，由于目前还用不上太多别的功能，全都选择no。<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsrtyy8rp5j20gq0c6jxf.jpg" alt></p><p>2.进入目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cd my-project</span><br></pre></td></tr></table></figure><p>3.安装项目依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install</span><br></pre></td></tr></table></figure><p>4.启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm run dev</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsrtz4t7s6j20ef05jmx3.jpg" alt></p><p>到这里已经成功创建了一个vue项目。</p><p>5.初始项目目录及说明：</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsrtzvdxqij205x090t8p.jpg" alt></p><p><a href="https://note.youdao.com/" target="_blank" rel="noopener">https://blog.csdn.net/Solo95/article/details/72355098</a><br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru08a8pvj20ns0ed74s.jpg" alt></p><p>6.打开浏览器，将看到右边的大logo：</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsrtx6wcjkj20wc0iwwt5.jpg" alt></p><h1 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h1><p>包含三个组件：根组件App.vue展现内容、 输入表单部分组件Form.vue和输出展示部分组件Output.vue。</p><p>首先在components目录下创建两个组件：Form.vue和Output.vue<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru0icp1pj20je03n74g.jpg" alt><br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru0mvkjuj20da04b0so.jpg" alt></p><h2 id="1-Form-vue表单部分"><a href="#1-Form-vue表单部分" class="headerlink" title="1. Form.vue表单部分"></a>1. Form.vue表单部分</h2><p>1）</p><ul><li>主要结构<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru0t0ox8j20vz0buab4.jpg" alt></li></ul><p>2）</p><ul><li>给input绑定值==v-model=”textTodo”== ，并在data中声明</li><li>实现点击button，监听事件 ==v-on:click=”formSubmit()”== 拿到输入的值</li><li>采用事件注册的方法==this.$emit()==，默认一个参数，第一个参数formSubmit2为方法</li><li>$emit自定义事件Vue自定义事件是为组件间通信设计，自定义事件提供 ==$on、$off、$once、$emit== 几个api<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru15lxgjj20ij0ee3yu.jpg" alt></li></ul><h2 id="2-App-vue"><a href="#2-App-vue" class="headerlink" title="2. App.vue"></a>2. App.vue</h2><p>1）</p><ul><li>根组件调用两个子组件的地方，是两者的联系点，所以在调用Form组件的地方监听this.$emit()中的方法</li><li>根组件中需要用一个方法接收传过去的待翻译的内容，所以在Form组件的this.$emit()中加上参数textTodo，返回根组件transText方法添加形参text</li></ul><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru1fn9z1j20f50ak3yv.jpg" alt></p><p>2）</p><ul><li><p>使用 <a href="https://note.youdao.com/" target="_blank" rel="noopener">https://tech.yandex.com/</a> 的翻译Tranlsate API<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru1rjsfxj20m50cj0t5.jpg" alt></p></li><li><p>这里需要一个API Key，必须通过key请求翻译的一些文本内容<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru2261nsj20z50a9my7.jpg" alt></p></li><li><p>创建属于自己的API keys<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru26ncvoj20p106haa8.jpg" alt></p></li></ul><ul><li>在document里可以看到有很多语言，需要什么语言就将其code写入表单select的option的value值中去。<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru2z15e6j20nv0geq3r.jpg" alt></li></ul><p>3）</p><ul><li>在使用http请求对应的接口前必须先安装Vue resource网络请求模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install vue-resoure --save</span><br></pre></td></tr></table></figure><ul><li>在main.js中引入这个模块，用Vue.use使用中间件引入，接着就可以使用http了，在发送请求后，使用then方法来处理响应结果，then方法有两个参数，第一个参数是响应成功时的回调函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Lambda写法</span><br><span class="line">this.$http.get(&apos;/someUrl&apos;, [options]).then((response) =&gt; &#123;</span><br><span class="line">    // 响应成功回调</span><br><span class="line">&#125;, (response) =&gt; &#123;</span><br><span class="line">    // 响应错误回调</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru2at45gj20j808842n.jpg" alt></p><p>4）</p><ul><li>之前给Form的方法transText()参数有languange和text </li></ul><p>==[解决选中语言的问题]==</p><p>select上绑定一个==v-model=”language”== 在data中初始化，与之前传text同理，给formSubmit方法加一个参数language就好了，http.get中将lang的值修改为language</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru359m7wj20ps05yq39.jpg" alt></p><ul><li><p>请求完的返回值response通过箭头函数then返回，打印response，查看在body中有个text数组，我们需要的已翻译好的文本为数组中第0个值，因此使用==response.body.text[0]==<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru3alfd4j21hc0oc7ua.jpg" alt></p></li><li><p>接着将这个值赋值给transedText，而这个值应该传到Output.vue中去显示<br>绑定属性==v-text=”transedText”==<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru3hnu4dj20f50ak3yv.jpg" alt></p></li></ul><h2 id="3-Output-vue"><a href="#3-Output-vue" class="headerlink" title="3.Output.vue"></a>3.Output.vue</h2><ul><li>很简单，只需定义一个属性props，用于传值transedText，并显示出来。</li><li>在vue中，组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。</li></ul><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru40rfhdj20hb088wek.jpg" alt></p><h1 id="四、样式"><a href="#四、样式" class="headerlink" title="四、样式"></a>四、样式</h1><p><a href="https://note.youdao.com/" target="_blank" rel="noopener">https://github.com/iview/iview</a></p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru47syi6j20d60ahmyg.jpg" alt></p><p>iview与使用vue-resource差不多</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru52wdukj20ge09s3yz.jpg" alt></p><h1 id="五、打包"><a href="#五、打包" class="headerlink" title="五、打包"></a>五、打包</h1><p>vue-cli可以直接用以下命令快速打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm run build</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru59msgxj20gb0gydgl.jpg" alt></p><p>第一次打包好后打开是一片空白</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru5o39syj20hn04iq30.jpg" alt></p><p>此处需要注意将文件index.js中的==assetsPublicPath==值改为相对路径（==/–&gt;./==），否则打包好后请求不到资源显示空白，因为vue是使用的绝对路径。</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru5i5b0qj20qp0e8q4w.jpg" alt></p><p>改了以后整体页面显示，但静态文件还是没有</p><p><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru5vidtaj20o70oddh7.jpg" alt></p><p>这两个404的文件所在路径能被正确访问应该是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/static/fonts/ionicons.05acfdb.woff</span><br><span class="line">/static/fonts/ionicons.24712f6.ttf</span><br></pre></td></tr></table></figure><p>但是前面对了两级目录/static/css所以找不到</p><p>参考<a href="https://note.youdao.com/" target="_blank" rel="noopener">https://juejin.im/post/5a75c8ce5188257a624c9ff1</a> 顺利解决！<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru60fmenj20ji05odg3.jpg" alt></p><p>之后只需要将dist文件夹中的内容放到服务器上就可以访问了！<br><img src="http://ww1.sinaimg.cn/large/720b6cbagy1fsru6a9henj20po0lzwfh.jpg" alt></p><h1 id="六、收获与不足"><a href="#六、收获与不足" class="headerlink" title="六、收获与不足"></a>六、收获与不足</h1><h2 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h2><p>熟悉基础语法、核心功能、基础概念、使用iView安装依赖的模块、调用API的方法和构建项目到打包的过程。</p><h2 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h2><p>布局简单，功能单一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚开始接触Vue，想通过一些实例对其使用更加熟悉。&lt;/p&gt;
&lt;h1 id=&quot;一、搭建过程与环境&quot;&gt;&lt;a href=&quot;#一、搭建过程与环境&quot; class=&quot;headerlink&quot; title=&quot;一、搭建过程与环境&quot;&gt;&lt;/a&gt;一、搭建过程与环境&lt;/h1&gt;&lt;p&gt;网上已经有很多教程
      
    
    </summary>
    
      <category term="前端" scheme="https://herasu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://herasu.github.io/tags/vue/"/>
    
      <category term="vue-cli" scheme="https://herasu.github.io/tags/vue-cli/"/>
    
      <category term="share" scheme="https://herasu.github.io/tags/share/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://herasu.github.io/2018/06/22/hello-world/"/>
    <id>https://herasu.github.io/2018/06/22/hello-world/</id>
    <published>2018-06-22T02:30:28.443Z</published>
    <updated>2018-06-22T02:30:28.443Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
